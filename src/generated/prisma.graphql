# source: http://localhost:4466
# timestamp: Sun Oct 07 2018 22:09:15 GMT-0400 (EDT)

type Account implements Node {
  id: ID!
  name: String!
  balance: Float!
  transactions(where: TransactionWhereInput, orderBy: TransactionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Transaction!]
}

"""A connection to a list of items."""
type AccountConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [AccountEdge]!
  aggregate: AggregateAccount!
}

input AccountCreateInput {
  name: String!
  balance: Float!
  transactions: TransactionCreateManyInput
}

input AccountCreateManyInput {
  create: [AccountCreateInput!]
  connect: [AccountWhereUniqueInput!]
}

"""An edge in a connection."""
type AccountEdge {
  """The item at the end of the edge."""
  node: Account!

  """A cursor for use in pagination."""
  cursor: String!
}

enum AccountOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  balance_ASC
  balance_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type AccountPreviousValues {
  id: ID!
  name: String!
  balance: Float!
}

type AccountSubscriptionPayload {
  mutation: MutationType!
  node: Account
  updatedFields: [String!]
  previousValues: AccountPreviousValues
}

input AccountSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [AccountSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [AccountSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [AccountSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: AccountWhereInput
}

input AccountUpdateDataInput {
  name: String
  balance: Float
  transactions: TransactionUpdateManyInput
}

input AccountUpdateInput {
  name: String
  balance: Float
  transactions: TransactionUpdateManyInput
}

input AccountUpdateManyInput {
  create: [AccountCreateInput!]
  connect: [AccountWhereUniqueInput!]
  disconnect: [AccountWhereUniqueInput!]
  delete: [AccountWhereUniqueInput!]
  update: [AccountUpdateWithWhereUniqueNestedInput!]
  upsert: [AccountUpsertWithWhereUniqueNestedInput!]
}

input AccountUpdateWithWhereUniqueNestedInput {
  where: AccountWhereUniqueInput!
  data: AccountUpdateDataInput!
}

input AccountUpsertWithWhereUniqueNestedInput {
  where: AccountWhereUniqueInput!
  update: AccountUpdateDataInput!
  create: AccountCreateInput!
}

input AccountWhereInput {
  """Logical AND on all given filters."""
  AND: [AccountWhereInput!]

  """Logical OR on all given filters."""
  OR: [AccountWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [AccountWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  name: String

  """All values that are not equal to given value."""
  name_not: String

  """All values that are contained in given list."""
  name_in: [String!]

  """All values that are not contained in given list."""
  name_not_in: [String!]

  """All values less than the given value."""
  name_lt: String

  """All values less than or equal the given value."""
  name_lte: String

  """All values greater than the given value."""
  name_gt: String

  """All values greater than or equal the given value."""
  name_gte: String

  """All values containing the given string."""
  name_contains: String

  """All values not containing the given string."""
  name_not_contains: String

  """All values starting with the given string."""
  name_starts_with: String

  """All values not starting with the given string."""
  name_not_starts_with: String

  """All values ending with the given string."""
  name_ends_with: String

  """All values not ending with the given string."""
  name_not_ends_with: String
  balance: Float

  """All values that are not equal to given value."""
  balance_not: Float

  """All values that are contained in given list."""
  balance_in: [Float!]

  """All values that are not contained in given list."""
  balance_not_in: [Float!]

  """All values less than the given value."""
  balance_lt: Float

  """All values less than or equal the given value."""
  balance_lte: Float

  """All values greater than the given value."""
  balance_gt: Float

  """All values greater than or equal the given value."""
  balance_gte: Float
  transactions_every: TransactionWhereInput
  transactions_some: TransactionWhereInput
  transactions_none: TransactionWhereInput
}

input AccountWhereUniqueInput {
  id: ID
}

type AggregateAccount {
  count: Int!
}

type AggregateBook {
  count: Int!
}

type AggregateBookTransaction {
  count: Int!
}

type AggregateBudget {
  count: Int!
}

type AggregateContactInfo {
  count: Int!
}

type AggregateCourse {
  count: Int!
}

type AggregateCourseAssignment {
  count: Int!
}

type AggregateCourseLecture {
  count: Int!
}

type AggregateEducation {
  count: Int!
}

type AggregateEvent {
  count: Int!
}

type AggregateFavorite {
  count: Int!
}

type AggregateFinanceGoals {
  count: Int!
}

type AggregateFixedCost {
  count: Int!
}

type AggregateGoodOrService {
  count: Int!
}

type AggregateHuman {
  count: Int!
}

type AggregateLocation {
  count: Int!
}

type AggregateMovie {
  count: Int!
}

type AggregateMovieTransaction {
  count: Int!
}

type AggregateOverview {
  count: Int!
}

type AggregateSchool {
  count: Int!
}

type AggregateTask {
  count: Int!
}

type AggregateTimeline {
  count: Int!
}

type AggregateTransaction {
  count: Int!
}

type AggregateTransactionSplit {
  count: Int!
}

type AggregateTvEpisode {
  count: Int!
}

type AggregateTvEpisodeTransaction {
  count: Int!
}

type AggregateTvShow {
  count: Int!
}

type AggregateWeightHistoryItem {
  count: Int!
}

type AggregateWishList {
  count: Int!
}

type BatchPayload {
  """The number of nodes that have been affected by the Batch operation."""
  count: Long!
}

type Book implements Node {
  id: ID!
  name: String
  author: String
  release_date: DateTime!
  word_count: Int
}

"""A connection to a list of items."""
type BookConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [BookEdge]!
  aggregate: AggregateBook!
}

input BookCreateInput {
  name: String
  author: String
  release_date: DateTime!
  word_count: Int
}

input BookCreateOneInput {
  create: BookCreateInput
  connect: BookWhereUniqueInput
}

"""An edge in a connection."""
type BookEdge {
  """The item at the end of the edge."""
  node: Book!

  """A cursor for use in pagination."""
  cursor: String!
}

enum BookOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  author_ASC
  author_DESC
  release_date_ASC
  release_date_DESC
  word_count_ASC
  word_count_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type BookPreviousValues {
  id: ID!
  name: String
  author: String
  release_date: DateTime!
  word_count: Int
}

type BookSubscriptionPayload {
  mutation: MutationType!
  node: Book
  updatedFields: [String!]
  previousValues: BookPreviousValues
}

input BookSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [BookSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [BookSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [BookSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: BookWhereInput
}

type BookTransaction implements Node {
  id: ID!
  book(where: BookWhereInput): Book
  date_started: DateTime
  date_finished: DateTime
}

"""A connection to a list of items."""
type BookTransactionConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [BookTransactionEdge]!
  aggregate: AggregateBookTransaction!
}

input BookTransactionCreateInput {
  date_started: DateTime
  date_finished: DateTime
  book: BookCreateOneInput
}

input BookTransactionCreateManyInput {
  create: [BookTransactionCreateInput!]
  connect: [BookTransactionWhereUniqueInput!]
}

"""An edge in a connection."""
type BookTransactionEdge {
  """The item at the end of the edge."""
  node: BookTransaction!

  """A cursor for use in pagination."""
  cursor: String!
}

enum BookTransactionOrderByInput {
  id_ASC
  id_DESC
  date_started_ASC
  date_started_DESC
  date_finished_ASC
  date_finished_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type BookTransactionPreviousValues {
  id: ID!
  date_started: DateTime
  date_finished: DateTime
}

type BookTransactionSubscriptionPayload {
  mutation: MutationType!
  node: BookTransaction
  updatedFields: [String!]
  previousValues: BookTransactionPreviousValues
}

input BookTransactionSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [BookTransactionSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [BookTransactionSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [BookTransactionSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: BookTransactionWhereInput
}

input BookTransactionUpdateDataInput {
  date_started: DateTime
  date_finished: DateTime
  book: BookUpdateOneInput
}

input BookTransactionUpdateInput {
  date_started: DateTime
  date_finished: DateTime
  book: BookUpdateOneInput
}

input BookTransactionUpdateManyInput {
  create: [BookTransactionCreateInput!]
  connect: [BookTransactionWhereUniqueInput!]
  disconnect: [BookTransactionWhereUniqueInput!]
  delete: [BookTransactionWhereUniqueInput!]
  update: [BookTransactionUpdateWithWhereUniqueNestedInput!]
  upsert: [BookTransactionUpsertWithWhereUniqueNestedInput!]
}

input BookTransactionUpdateWithWhereUniqueNestedInput {
  where: BookTransactionWhereUniqueInput!
  data: BookTransactionUpdateDataInput!
}

input BookTransactionUpsertWithWhereUniqueNestedInput {
  where: BookTransactionWhereUniqueInput!
  update: BookTransactionUpdateDataInput!
  create: BookTransactionCreateInput!
}

input BookTransactionWhereInput {
  """Logical AND on all given filters."""
  AND: [BookTransactionWhereInput!]

  """Logical OR on all given filters."""
  OR: [BookTransactionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [BookTransactionWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  date_started: DateTime

  """All values that are not equal to given value."""
  date_started_not: DateTime

  """All values that are contained in given list."""
  date_started_in: [DateTime!]

  """All values that are not contained in given list."""
  date_started_not_in: [DateTime!]

  """All values less than the given value."""
  date_started_lt: DateTime

  """All values less than or equal the given value."""
  date_started_lte: DateTime

  """All values greater than the given value."""
  date_started_gt: DateTime

  """All values greater than or equal the given value."""
  date_started_gte: DateTime
  date_finished: DateTime

  """All values that are not equal to given value."""
  date_finished_not: DateTime

  """All values that are contained in given list."""
  date_finished_in: [DateTime!]

  """All values that are not contained in given list."""
  date_finished_not_in: [DateTime!]

  """All values less than the given value."""
  date_finished_lt: DateTime

  """All values less than or equal the given value."""
  date_finished_lte: DateTime

  """All values greater than the given value."""
  date_finished_gt: DateTime

  """All values greater than or equal the given value."""
  date_finished_gte: DateTime
  book: BookWhereInput
}

input BookTransactionWhereUniqueInput {
  id: ID
}

input BookUpdateDataInput {
  name: String
  author: String
  release_date: DateTime
  word_count: Int
}

input BookUpdateInput {
  name: String
  author: String
  release_date: DateTime
  word_count: Int
}

input BookUpdateOneInput {
  create: BookCreateInput
  connect: BookWhereUniqueInput
  disconnect: Boolean
  delete: Boolean
  update: BookUpdateDataInput
  upsert: BookUpsertNestedInput
}

input BookUpsertNestedInput {
  update: BookUpdateDataInput!
  create: BookCreateInput!
}

input BookWhereInput {
  """Logical AND on all given filters."""
  AND: [BookWhereInput!]

  """Logical OR on all given filters."""
  OR: [BookWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [BookWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  name: String

  """All values that are not equal to given value."""
  name_not: String

  """All values that are contained in given list."""
  name_in: [String!]

  """All values that are not contained in given list."""
  name_not_in: [String!]

  """All values less than the given value."""
  name_lt: String

  """All values less than or equal the given value."""
  name_lte: String

  """All values greater than the given value."""
  name_gt: String

  """All values greater than or equal the given value."""
  name_gte: String

  """All values containing the given string."""
  name_contains: String

  """All values not containing the given string."""
  name_not_contains: String

  """All values starting with the given string."""
  name_starts_with: String

  """All values not starting with the given string."""
  name_not_starts_with: String

  """All values ending with the given string."""
  name_ends_with: String

  """All values not ending with the given string."""
  name_not_ends_with: String
  author: String

  """All values that are not equal to given value."""
  author_not: String

  """All values that are contained in given list."""
  author_in: [String!]

  """All values that are not contained in given list."""
  author_not_in: [String!]

  """All values less than the given value."""
  author_lt: String

  """All values less than or equal the given value."""
  author_lte: String

  """All values greater than the given value."""
  author_gt: String

  """All values greater than or equal the given value."""
  author_gte: String

  """All values containing the given string."""
  author_contains: String

  """All values not containing the given string."""
  author_not_contains: String

  """All values starting with the given string."""
  author_starts_with: String

  """All values not starting with the given string."""
  author_not_starts_with: String

  """All values ending with the given string."""
  author_ends_with: String

  """All values not ending with the given string."""
  author_not_ends_with: String
  release_date: DateTime

  """All values that are not equal to given value."""
  release_date_not: DateTime

  """All values that are contained in given list."""
  release_date_in: [DateTime!]

  """All values that are not contained in given list."""
  release_date_not_in: [DateTime!]

  """All values less than the given value."""
  release_date_lt: DateTime

  """All values less than or equal the given value."""
  release_date_lte: DateTime

  """All values greater than the given value."""
  release_date_gt: DateTime

  """All values greater than or equal the given value."""
  release_date_gte: DateTime
  word_count: Int

  """All values that are not equal to given value."""
  word_count_not: Int

  """All values that are contained in given list."""
  word_count_in: [Int!]

  """All values that are not contained in given list."""
  word_count_not_in: [Int!]

  """All values less than the given value."""
  word_count_lt: Int

  """All values less than or equal the given value."""
  word_count_lte: Int

  """All values greater than the given value."""
  word_count_gt: Int

  """All values greater than or equal the given value."""
  word_count_gte: Int
}

input BookWhereUniqueInput {
  id: ID
}

type Budget implements Node {
  id: ID!
  flexible_spending: Float
  total_fixed_cost: Float
  fixed_costs(where: FixedCostWhereInput, orderBy: FixedCostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [FixedCost!]
}

"""A connection to a list of items."""
type BudgetConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [BudgetEdge]!
  aggregate: AggregateBudget!
}

input BudgetCreateInput {
  flexible_spending: Float
  total_fixed_cost: Float
  fixed_costs: FixedCostCreateManyInput
}

input BudgetCreateOneInput {
  create: BudgetCreateInput
  connect: BudgetWhereUniqueInput
}

"""An edge in a connection."""
type BudgetEdge {
  """The item at the end of the edge."""
  node: Budget!

  """A cursor for use in pagination."""
  cursor: String!
}

enum BudgetOrderByInput {
  id_ASC
  id_DESC
  flexible_spending_ASC
  flexible_spending_DESC
  total_fixed_cost_ASC
  total_fixed_cost_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type BudgetPreviousValues {
  id: ID!
  flexible_spending: Float
  total_fixed_cost: Float
}

type BudgetSubscriptionPayload {
  mutation: MutationType!
  node: Budget
  updatedFields: [String!]
  previousValues: BudgetPreviousValues
}

input BudgetSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [BudgetSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [BudgetSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [BudgetSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: BudgetWhereInput
}

input BudgetUpdateDataInput {
  flexible_spending: Float
  total_fixed_cost: Float
  fixed_costs: FixedCostUpdateManyInput
}

input BudgetUpdateInput {
  flexible_spending: Float
  total_fixed_cost: Float
  fixed_costs: FixedCostUpdateManyInput
}

input BudgetUpdateOneInput {
  create: BudgetCreateInput
  connect: BudgetWhereUniqueInput
  disconnect: Boolean
  delete: Boolean
  update: BudgetUpdateDataInput
  upsert: BudgetUpsertNestedInput
}

input BudgetUpsertNestedInput {
  update: BudgetUpdateDataInput!
  create: BudgetCreateInput!
}

input BudgetWhereInput {
  """Logical AND on all given filters."""
  AND: [BudgetWhereInput!]

  """Logical OR on all given filters."""
  OR: [BudgetWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [BudgetWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  flexible_spending: Float

  """All values that are not equal to given value."""
  flexible_spending_not: Float

  """All values that are contained in given list."""
  flexible_spending_in: [Float!]

  """All values that are not contained in given list."""
  flexible_spending_not_in: [Float!]

  """All values less than the given value."""
  flexible_spending_lt: Float

  """All values less than or equal the given value."""
  flexible_spending_lte: Float

  """All values greater than the given value."""
  flexible_spending_gt: Float

  """All values greater than or equal the given value."""
  flexible_spending_gte: Float
  total_fixed_cost: Float

  """All values that are not equal to given value."""
  total_fixed_cost_not: Float

  """All values that are contained in given list."""
  total_fixed_cost_in: [Float!]

  """All values that are not contained in given list."""
  total_fixed_cost_not_in: [Float!]

  """All values less than the given value."""
  total_fixed_cost_lt: Float

  """All values less than or equal the given value."""
  total_fixed_cost_lte: Float

  """All values greater than the given value."""
  total_fixed_cost_gt: Float

  """All values greater than or equal the given value."""
  total_fixed_cost_gte: Float
  fixed_costs_every: FixedCostWhereInput
  fixed_costs_some: FixedCostWhereInput
  fixed_costs_none: FixedCostWhereInput
}

input BudgetWhereUniqueInput {
  id: ID
}

type ContactInfo {
  email: String
  phone_number: String
  twitter: String
  snapchat: String
  human(where: HumanWhereInput): Human!
}

"""A connection to a list of items."""
type ContactInfoConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [ContactInfoEdge]!
  aggregate: AggregateContactInfo!
}

input ContactInfoCreateInput {
  email: String
  phone_number: String
  twitter: String
  snapchat: String
  human: HumanCreateOneWithoutContactInput!
}

input ContactInfoCreateOneWithoutHumanInput {
  create: ContactInfoCreateWithoutHumanInput
}

input ContactInfoCreateWithoutHumanInput {
  email: String
  phone_number: String
  twitter: String
  snapchat: String
}

"""An edge in a connection."""
type ContactInfoEdge {
  """The item at the end of the edge."""
  node: ContactInfo!

  """A cursor for use in pagination."""
  cursor: String!
}

enum ContactInfoOrderByInput {
  email_ASC
  email_DESC
  phone_number_ASC
  phone_number_DESC
  twitter_ASC
  twitter_DESC
  snapchat_ASC
  snapchat_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type ContactInfoPreviousValues {
  email: String
  phone_number: String
  twitter: String
  snapchat: String
}

type ContactInfoSubscriptionPayload {
  mutation: MutationType!
  node: ContactInfo
  updatedFields: [String!]
  previousValues: ContactInfoPreviousValues
}

input ContactInfoSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [ContactInfoSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [ContactInfoSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [ContactInfoSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: ContactInfoWhereInput
}

input ContactInfoUpdateInput {
  email: String
  phone_number: String
  twitter: String
  snapchat: String
  human: HumanUpdateOneWithoutContactInput
}

input ContactInfoUpdateOneWithoutHumanInput {
  create: ContactInfoCreateWithoutHumanInput
  disconnect: Boolean
  delete: Boolean
  update: ContactInfoUpdateWithoutHumanDataInput
  upsert: ContactInfoUpsertWithoutHumanInput
}

input ContactInfoUpdateWithoutHumanDataInput {
  email: String
  phone_number: String
  twitter: String
  snapchat: String
}

input ContactInfoUpsertWithoutHumanInput {
  update: ContactInfoUpdateWithoutHumanDataInput!
  create: ContactInfoCreateWithoutHumanInput!
}

input ContactInfoWhereInput {
  """Logical AND on all given filters."""
  AND: [ContactInfoWhereInput!]

  """Logical OR on all given filters."""
  OR: [ContactInfoWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [ContactInfoWhereInput!]
  email: String

  """All values that are not equal to given value."""
  email_not: String

  """All values that are contained in given list."""
  email_in: [String!]

  """All values that are not contained in given list."""
  email_not_in: [String!]

  """All values less than the given value."""
  email_lt: String

  """All values less than or equal the given value."""
  email_lte: String

  """All values greater than the given value."""
  email_gt: String

  """All values greater than or equal the given value."""
  email_gte: String

  """All values containing the given string."""
  email_contains: String

  """All values not containing the given string."""
  email_not_contains: String

  """All values starting with the given string."""
  email_starts_with: String

  """All values not starting with the given string."""
  email_not_starts_with: String

  """All values ending with the given string."""
  email_ends_with: String

  """All values not ending with the given string."""
  email_not_ends_with: String
  phone_number: String

  """All values that are not equal to given value."""
  phone_number_not: String

  """All values that are contained in given list."""
  phone_number_in: [String!]

  """All values that are not contained in given list."""
  phone_number_not_in: [String!]

  """All values less than the given value."""
  phone_number_lt: String

  """All values less than or equal the given value."""
  phone_number_lte: String

  """All values greater than the given value."""
  phone_number_gt: String

  """All values greater than or equal the given value."""
  phone_number_gte: String

  """All values containing the given string."""
  phone_number_contains: String

  """All values not containing the given string."""
  phone_number_not_contains: String

  """All values starting with the given string."""
  phone_number_starts_with: String

  """All values not starting with the given string."""
  phone_number_not_starts_with: String

  """All values ending with the given string."""
  phone_number_ends_with: String

  """All values not ending with the given string."""
  phone_number_not_ends_with: String
  twitter: String

  """All values that are not equal to given value."""
  twitter_not: String

  """All values that are contained in given list."""
  twitter_in: [String!]

  """All values that are not contained in given list."""
  twitter_not_in: [String!]

  """All values less than the given value."""
  twitter_lt: String

  """All values less than or equal the given value."""
  twitter_lte: String

  """All values greater than the given value."""
  twitter_gt: String

  """All values greater than or equal the given value."""
  twitter_gte: String

  """All values containing the given string."""
  twitter_contains: String

  """All values not containing the given string."""
  twitter_not_contains: String

  """All values starting with the given string."""
  twitter_starts_with: String

  """All values not starting with the given string."""
  twitter_not_starts_with: String

  """All values ending with the given string."""
  twitter_ends_with: String

  """All values not ending with the given string."""
  twitter_not_ends_with: String
  snapchat: String

  """All values that are not equal to given value."""
  snapchat_not: String

  """All values that are contained in given list."""
  snapchat_in: [String!]

  """All values that are not contained in given list."""
  snapchat_not_in: [String!]

  """All values less than the given value."""
  snapchat_lt: String

  """All values less than or equal the given value."""
  snapchat_lte: String

  """All values greater than the given value."""
  snapchat_gt: String

  """All values greater than or equal the given value."""
  snapchat_gte: String

  """All values containing the given string."""
  snapchat_contains: String

  """All values not containing the given string."""
  snapchat_not_contains: String

  """All values starting with the given string."""
  snapchat_starts_with: String

  """All values not starting with the given string."""
  snapchat_not_starts_with: String

  """All values ending with the given string."""
  snapchat_ends_with: String

  """All values not ending with the given string."""
  snapchat_not_ends_with: String
  human: HumanWhereInput
}

type Course {
  name: String
  subject: ID!
  completion: Float!
  start_date: DateTime!
  end_date: DateTime!
  lectures(where: CourseLectureWhereInput, orderBy: CourseLectureOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CourseLecture!]
  assignments(where: CourseAssignmentWhereInput, orderBy: CourseAssignmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CourseAssignment!]
  school(where: SchoolWhereInput): School!
}

type CourseAssignment implements Node {
  id: ID!
  description: String!
  grade: Float
  course(where: CourseWhereInput): Course!
}

"""A connection to a list of items."""
type CourseAssignmentConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [CourseAssignmentEdge]!
  aggregate: AggregateCourseAssignment!
}

input CourseAssignmentCreateInput {
  description: String!
  grade: Float
  course: CourseCreateOneWithoutAssignmentsInput!
}

input CourseAssignmentCreateManyWithoutCourseInput {
  create: [CourseAssignmentCreateWithoutCourseInput!]
  connect: [CourseAssignmentWhereUniqueInput!]
}

input CourseAssignmentCreateWithoutCourseInput {
  description: String!
  grade: Float
}

"""An edge in a connection."""
type CourseAssignmentEdge {
  """The item at the end of the edge."""
  node: CourseAssignment!

  """A cursor for use in pagination."""
  cursor: String!
}

enum CourseAssignmentOrderByInput {
  id_ASC
  id_DESC
  description_ASC
  description_DESC
  grade_ASC
  grade_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type CourseAssignmentPreviousValues {
  id: ID!
  description: String!
  grade: Float
}

type CourseAssignmentSubscriptionPayload {
  mutation: MutationType!
  node: CourseAssignment
  updatedFields: [String!]
  previousValues: CourseAssignmentPreviousValues
}

input CourseAssignmentSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [CourseAssignmentSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [CourseAssignmentSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [CourseAssignmentSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: CourseAssignmentWhereInput
}

input CourseAssignmentUpdateInput {
  description: String
  grade: Float
  course: CourseUpdateOneWithoutAssignmentsInput
}

input CourseAssignmentUpdateManyWithoutCourseInput {
  create: [CourseAssignmentCreateWithoutCourseInput!]
  connect: [CourseAssignmentWhereUniqueInput!]
  disconnect: [CourseAssignmentWhereUniqueInput!]
  delete: [CourseAssignmentWhereUniqueInput!]
  update: [CourseAssignmentUpdateWithWhereUniqueWithoutCourseInput!]
  upsert: [CourseAssignmentUpsertWithWhereUniqueWithoutCourseInput!]
}

input CourseAssignmentUpdateWithoutCourseDataInput {
  description: String
  grade: Float
}

input CourseAssignmentUpdateWithWhereUniqueWithoutCourseInput {
  where: CourseAssignmentWhereUniqueInput!
  data: CourseAssignmentUpdateWithoutCourseDataInput!
}

input CourseAssignmentUpsertWithWhereUniqueWithoutCourseInput {
  where: CourseAssignmentWhereUniqueInput!
  update: CourseAssignmentUpdateWithoutCourseDataInput!
  create: CourseAssignmentCreateWithoutCourseInput!
}

input CourseAssignmentWhereInput {
  """Logical AND on all given filters."""
  AND: [CourseAssignmentWhereInput!]

  """Logical OR on all given filters."""
  OR: [CourseAssignmentWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [CourseAssignmentWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  description: String

  """All values that are not equal to given value."""
  description_not: String

  """All values that are contained in given list."""
  description_in: [String!]

  """All values that are not contained in given list."""
  description_not_in: [String!]

  """All values less than the given value."""
  description_lt: String

  """All values less than or equal the given value."""
  description_lte: String

  """All values greater than the given value."""
  description_gt: String

  """All values greater than or equal the given value."""
  description_gte: String

  """All values containing the given string."""
  description_contains: String

  """All values not containing the given string."""
  description_not_contains: String

  """All values starting with the given string."""
  description_starts_with: String

  """All values not starting with the given string."""
  description_not_starts_with: String

  """All values ending with the given string."""
  description_ends_with: String

  """All values not ending with the given string."""
  description_not_ends_with: String
  grade: Float

  """All values that are not equal to given value."""
  grade_not: Float

  """All values that are contained in given list."""
  grade_in: [Float!]

  """All values that are not contained in given list."""
  grade_not_in: [Float!]

  """All values less than the given value."""
  grade_lt: Float

  """All values less than or equal the given value."""
  grade_lte: Float

  """All values greater than the given value."""
  grade_gt: Float

  """All values greater than or equal the given value."""
  grade_gte: Float
  course: CourseWhereInput
}

input CourseAssignmentWhereUniqueInput {
  id: ID
}

"""A connection to a list of items."""
type CourseConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [CourseEdge]!
  aggregate: AggregateCourse!
}

input CourseCreateInput {
  name: String
  subject: ID!
  completion: Float!
  start_date: DateTime!
  end_date: DateTime!
  lectures: CourseLectureCreateManyWithoutCourseInput
  assignments: CourseAssignmentCreateManyWithoutCourseInput
  school: SchoolCreateOneInput!
}

input CourseCreateManyInput {
  create: [CourseCreateInput!]
}

input CourseCreateOneWithoutAssignmentsInput {
  create: CourseCreateWithoutAssignmentsInput
}

input CourseCreateOneWithoutLecturesInput {
  create: CourseCreateWithoutLecturesInput
}

input CourseCreateWithoutAssignmentsInput {
  name: String
  subject: ID!
  completion: Float!
  start_date: DateTime!
  end_date: DateTime!
  lectures: CourseLectureCreateManyWithoutCourseInput
  school: SchoolCreateOneInput!
}

input CourseCreateWithoutLecturesInput {
  name: String
  subject: ID!
  completion: Float!
  start_date: DateTime!
  end_date: DateTime!
  assignments: CourseAssignmentCreateManyWithoutCourseInput
  school: SchoolCreateOneInput!
}

"""An edge in a connection."""
type CourseEdge {
  """The item at the end of the edge."""
  node: Course!

  """A cursor for use in pagination."""
  cursor: String!
}

type CourseLecture implements Node {
  id: ID!
  title: String!
  description: String!
  course(where: CourseWhereInput): Course!
}

"""A connection to a list of items."""
type CourseLectureConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [CourseLectureEdge]!
  aggregate: AggregateCourseLecture!
}

input CourseLectureCreateInput {
  title: String!
  description: String!
  course: CourseCreateOneWithoutLecturesInput!
}

input CourseLectureCreateManyWithoutCourseInput {
  create: [CourseLectureCreateWithoutCourseInput!]
  connect: [CourseLectureWhereUniqueInput!]
}

input CourseLectureCreateWithoutCourseInput {
  title: String!
  description: String!
}

"""An edge in a connection."""
type CourseLectureEdge {
  """The item at the end of the edge."""
  node: CourseLecture!

  """A cursor for use in pagination."""
  cursor: String!
}

enum CourseLectureOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  description_ASC
  description_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type CourseLecturePreviousValues {
  id: ID!
  title: String!
  description: String!
}

type CourseLectureSubscriptionPayload {
  mutation: MutationType!
  node: CourseLecture
  updatedFields: [String!]
  previousValues: CourseLecturePreviousValues
}

input CourseLectureSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [CourseLectureSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [CourseLectureSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [CourseLectureSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: CourseLectureWhereInput
}

input CourseLectureUpdateInput {
  title: String
  description: String
  course: CourseUpdateOneWithoutLecturesInput
}

input CourseLectureUpdateManyWithoutCourseInput {
  create: [CourseLectureCreateWithoutCourseInput!]
  connect: [CourseLectureWhereUniqueInput!]
  disconnect: [CourseLectureWhereUniqueInput!]
  delete: [CourseLectureWhereUniqueInput!]
  update: [CourseLectureUpdateWithWhereUniqueWithoutCourseInput!]
  upsert: [CourseLectureUpsertWithWhereUniqueWithoutCourseInput!]
}

input CourseLectureUpdateWithoutCourseDataInput {
  title: String
  description: String
}

input CourseLectureUpdateWithWhereUniqueWithoutCourseInput {
  where: CourseLectureWhereUniqueInput!
  data: CourseLectureUpdateWithoutCourseDataInput!
}

input CourseLectureUpsertWithWhereUniqueWithoutCourseInput {
  where: CourseLectureWhereUniqueInput!
  update: CourseLectureUpdateWithoutCourseDataInput!
  create: CourseLectureCreateWithoutCourseInput!
}

input CourseLectureWhereInput {
  """Logical AND on all given filters."""
  AND: [CourseLectureWhereInput!]

  """Logical OR on all given filters."""
  OR: [CourseLectureWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [CourseLectureWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  title: String

  """All values that are not equal to given value."""
  title_not: String

  """All values that are contained in given list."""
  title_in: [String!]

  """All values that are not contained in given list."""
  title_not_in: [String!]

  """All values less than the given value."""
  title_lt: String

  """All values less than or equal the given value."""
  title_lte: String

  """All values greater than the given value."""
  title_gt: String

  """All values greater than or equal the given value."""
  title_gte: String

  """All values containing the given string."""
  title_contains: String

  """All values not containing the given string."""
  title_not_contains: String

  """All values starting with the given string."""
  title_starts_with: String

  """All values not starting with the given string."""
  title_not_starts_with: String

  """All values ending with the given string."""
  title_ends_with: String

  """All values not ending with the given string."""
  title_not_ends_with: String
  description: String

  """All values that are not equal to given value."""
  description_not: String

  """All values that are contained in given list."""
  description_in: [String!]

  """All values that are not contained in given list."""
  description_not_in: [String!]

  """All values less than the given value."""
  description_lt: String

  """All values less than or equal the given value."""
  description_lte: String

  """All values greater than the given value."""
  description_gt: String

  """All values greater than or equal the given value."""
  description_gte: String

  """All values containing the given string."""
  description_contains: String

  """All values not containing the given string."""
  description_not_contains: String

  """All values starting with the given string."""
  description_starts_with: String

  """All values not starting with the given string."""
  description_not_starts_with: String

  """All values ending with the given string."""
  description_ends_with: String

  """All values not ending with the given string."""
  description_not_ends_with: String
  course: CourseWhereInput
}

input CourseLectureWhereUniqueInput {
  id: ID
}

enum CourseOrderByInput {
  name_ASC
  name_DESC
  subject_ASC
  subject_DESC
  completion_ASC
  completion_DESC
  start_date_ASC
  start_date_DESC
  end_date_ASC
  end_date_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type CoursePreviousValues {
  name: String
  subject: ID!
  completion: Float!
  start_date: DateTime!
  end_date: DateTime!
}

type CourseSubscriptionPayload {
  mutation: MutationType!
  node: Course
  updatedFields: [String!]
  previousValues: CoursePreviousValues
}

input CourseSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [CourseSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [CourseSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [CourseSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: CourseWhereInput
}

input CourseUpdateInput {
  name: String
  subject: ID
  completion: Float
  start_date: DateTime
  end_date: DateTime
  lectures: CourseLectureUpdateManyWithoutCourseInput
  assignments: CourseAssignmentUpdateManyWithoutCourseInput
  school: SchoolUpdateOneInput
}

input CourseUpdateManyInput {
  create: [CourseCreateInput!]
}

input CourseUpdateOneWithoutAssignmentsInput {
  create: CourseCreateWithoutAssignmentsInput
  delete: Boolean
  update: CourseUpdateWithoutAssignmentsDataInput
  upsert: CourseUpsertWithoutAssignmentsInput
}

input CourseUpdateOneWithoutLecturesInput {
  create: CourseCreateWithoutLecturesInput
  delete: Boolean
  update: CourseUpdateWithoutLecturesDataInput
  upsert: CourseUpsertWithoutLecturesInput
}

input CourseUpdateWithoutAssignmentsDataInput {
  name: String
  subject: ID
  completion: Float
  start_date: DateTime
  end_date: DateTime
  lectures: CourseLectureUpdateManyWithoutCourseInput
  school: SchoolUpdateOneInput
}

input CourseUpdateWithoutLecturesDataInput {
  name: String
  subject: ID
  completion: Float
  start_date: DateTime
  end_date: DateTime
  assignments: CourseAssignmentUpdateManyWithoutCourseInput
  school: SchoolUpdateOneInput
}

input CourseUpsertWithoutAssignmentsInput {
  update: CourseUpdateWithoutAssignmentsDataInput!
  create: CourseCreateWithoutAssignmentsInput!
}

input CourseUpsertWithoutLecturesInput {
  update: CourseUpdateWithoutLecturesDataInput!
  create: CourseCreateWithoutLecturesInput!
}

input CourseWhereInput {
  """Logical AND on all given filters."""
  AND: [CourseWhereInput!]

  """Logical OR on all given filters."""
  OR: [CourseWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [CourseWhereInput!]
  name: String

  """All values that are not equal to given value."""
  name_not: String

  """All values that are contained in given list."""
  name_in: [String!]

  """All values that are not contained in given list."""
  name_not_in: [String!]

  """All values less than the given value."""
  name_lt: String

  """All values less than or equal the given value."""
  name_lte: String

  """All values greater than the given value."""
  name_gt: String

  """All values greater than or equal the given value."""
  name_gte: String

  """All values containing the given string."""
  name_contains: String

  """All values not containing the given string."""
  name_not_contains: String

  """All values starting with the given string."""
  name_starts_with: String

  """All values not starting with the given string."""
  name_not_starts_with: String

  """All values ending with the given string."""
  name_ends_with: String

  """All values not ending with the given string."""
  name_not_ends_with: String
  subject: ID

  """All values that are not equal to given value."""
  subject_not: ID

  """All values that are contained in given list."""
  subject_in: [ID!]

  """All values that are not contained in given list."""
  subject_not_in: [ID!]

  """All values less than the given value."""
  subject_lt: ID

  """All values less than or equal the given value."""
  subject_lte: ID

  """All values greater than the given value."""
  subject_gt: ID

  """All values greater than or equal the given value."""
  subject_gte: ID

  """All values containing the given string."""
  subject_contains: ID

  """All values not containing the given string."""
  subject_not_contains: ID

  """All values starting with the given string."""
  subject_starts_with: ID

  """All values not starting with the given string."""
  subject_not_starts_with: ID

  """All values ending with the given string."""
  subject_ends_with: ID

  """All values not ending with the given string."""
  subject_not_ends_with: ID
  completion: Float

  """All values that are not equal to given value."""
  completion_not: Float

  """All values that are contained in given list."""
  completion_in: [Float!]

  """All values that are not contained in given list."""
  completion_not_in: [Float!]

  """All values less than the given value."""
  completion_lt: Float

  """All values less than or equal the given value."""
  completion_lte: Float

  """All values greater than the given value."""
  completion_gt: Float

  """All values greater than or equal the given value."""
  completion_gte: Float
  start_date: DateTime

  """All values that are not equal to given value."""
  start_date_not: DateTime

  """All values that are contained in given list."""
  start_date_in: [DateTime!]

  """All values that are not contained in given list."""
  start_date_not_in: [DateTime!]

  """All values less than the given value."""
  start_date_lt: DateTime

  """All values less than or equal the given value."""
  start_date_lte: DateTime

  """All values greater than the given value."""
  start_date_gt: DateTime

  """All values greater than or equal the given value."""
  start_date_gte: DateTime
  end_date: DateTime

  """All values that are not equal to given value."""
  end_date_not: DateTime

  """All values that are contained in given list."""
  end_date_in: [DateTime!]

  """All values that are not contained in given list."""
  end_date_not_in: [DateTime!]

  """All values less than the given value."""
  end_date_lt: DateTime

  """All values less than or equal the given value."""
  end_date_lte: DateTime

  """All values greater than the given value."""
  end_date_gt: DateTime

  """All values greater than or equal the given value."""
  end_date_gte: DateTime
  lectures_every: CourseLectureWhereInput
  lectures_some: CourseLectureWhereInput
  lectures_none: CourseLectureWhereInput
  assignments_every: CourseAssignmentWhereInput
  assignments_some: CourseAssignmentWhereInput
  assignments_none: CourseAssignmentWhereInput
  school: SchoolWhereInput
}

scalar DateTime

type Education implements Node {
  id: ID!
  schools(where: SchoolWhereInput, orderBy: SchoolOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [School!]
  courses(where: CourseWhereInput, orderBy: CourseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Course!]
}

"""A connection to a list of items."""
type EducationConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [EducationEdge]!
  aggregate: AggregateEducation!
}

input EducationCreateInput {
  schools: SchoolCreateManyInput
  courses: CourseCreateManyInput
}

input EducationCreateOneInput {
  create: EducationCreateInput
  connect: EducationWhereUniqueInput
}

"""An edge in a connection."""
type EducationEdge {
  """The item at the end of the edge."""
  node: Education!

  """A cursor for use in pagination."""
  cursor: String!
}

enum EducationOrderByInput {
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type EducationPreviousValues {
  id: ID!
}

type EducationSubscriptionPayload {
  mutation: MutationType!
  node: Education
  updatedFields: [String!]
  previousValues: EducationPreviousValues
}

input EducationSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [EducationSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [EducationSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [EducationSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: EducationWhereInput
}

input EducationUpdateDataInput {
  schools: SchoolUpdateManyInput
  courses: CourseUpdateManyInput
}

input EducationUpdateInput {
  schools: SchoolUpdateManyInput
  courses: CourseUpdateManyInput
}

input EducationUpdateOneInput {
  create: EducationCreateInput
  connect: EducationWhereUniqueInput
  disconnect: Boolean
  delete: Boolean
  update: EducationUpdateDataInput
  upsert: EducationUpsertNestedInput
}

input EducationUpsertNestedInput {
  update: EducationUpdateDataInput!
  create: EducationCreateInput!
}

input EducationWhereInput {
  """Logical AND on all given filters."""
  AND: [EducationWhereInput!]

  """Logical OR on all given filters."""
  OR: [EducationWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [EducationWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  schools_every: SchoolWhereInput
  schools_some: SchoolWhereInput
  schools_none: SchoolWhereInput
  courses_every: CourseWhereInput
  courses_some: CourseWhereInput
  courses_none: CourseWhereInput
}

input EducationWhereUniqueInput {
  id: ID
}

type Event implements Node {
  id: ID!
  date: DateTime!
  location(where: LocationWhereInput): Location!
  type: EventType!
  description: String
  with(where: HumanWhereInput, orderBy: HumanOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Human!]
}

"""A connection to a list of items."""
type EventConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [EventEdge]!
  aggregate: AggregateEvent!
}

input EventCreateInput {
  date: DateTime!
  type: EventType!
  description: String
  location: LocationCreateOneWithoutEventsInput!
  with: HumanCreateManyInput
}

input EventCreateManyInput {
  create: [EventCreateInput!]
  connect: [EventWhereUniqueInput!]
}

input EventCreateManyWithoutLocationInput {
  create: [EventCreateWithoutLocationInput!]
  connect: [EventWhereUniqueInput!]
}

input EventCreateOneInput {
  create: EventCreateInput
  connect: EventWhereUniqueInput
}

input EventCreateWithoutLocationInput {
  date: DateTime!
  type: EventType!
  description: String
  with: HumanCreateManyInput
}

"""An edge in a connection."""
type EventEdge {
  """The item at the end of the edge."""
  node: Event!

  """A cursor for use in pagination."""
  cursor: String!
}

enum EventOrderByInput {
  id_ASC
  id_DESC
  date_ASC
  date_DESC
  type_ASC
  type_DESC
  description_ASC
  description_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type EventPreviousValues {
  id: ID!
  date: DateTime!
  type: EventType!
  description: String
}

type EventSubscriptionPayload {
  mutation: MutationType!
  node: Event
  updatedFields: [String!]
  previousValues: EventPreviousValues
}

input EventSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [EventSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [EventSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [EventSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: EventWhereInput
}

enum EventType {
  PHOTO
  THOUGHT
  MOVIE
  SEX
  DINING_OUT
  HOLIDAY
  ANNIVERSARY
}

input EventUpdateDataInput {
  date: DateTime
  type: EventType
  description: String
  location: LocationUpdateOneWithoutEventsInput
  with: HumanUpdateManyInput
}

input EventUpdateInput {
  date: DateTime
  type: EventType
  description: String
  location: LocationUpdateOneWithoutEventsInput
  with: HumanUpdateManyInput
}

input EventUpdateManyInput {
  create: [EventCreateInput!]
  connect: [EventWhereUniqueInput!]
  disconnect: [EventWhereUniqueInput!]
  delete: [EventWhereUniqueInput!]
  update: [EventUpdateWithWhereUniqueNestedInput!]
  upsert: [EventUpsertWithWhereUniqueNestedInput!]
}

input EventUpdateManyWithoutLocationInput {
  create: [EventCreateWithoutLocationInput!]
  connect: [EventWhereUniqueInput!]
  disconnect: [EventWhereUniqueInput!]
  delete: [EventWhereUniqueInput!]
  update: [EventUpdateWithWhereUniqueWithoutLocationInput!]
  upsert: [EventUpsertWithWhereUniqueWithoutLocationInput!]
}

input EventUpdateOneInput {
  create: EventCreateInput
  connect: EventWhereUniqueInput
  disconnect: Boolean
  delete: Boolean
  update: EventUpdateDataInput
  upsert: EventUpsertNestedInput
}

input EventUpdateWithoutLocationDataInput {
  date: DateTime
  type: EventType
  description: String
  with: HumanUpdateManyInput
}

input EventUpdateWithWhereUniqueNestedInput {
  where: EventWhereUniqueInput!
  data: EventUpdateDataInput!
}

input EventUpdateWithWhereUniqueWithoutLocationInput {
  where: EventWhereUniqueInput!
  data: EventUpdateWithoutLocationDataInput!
}

input EventUpsertNestedInput {
  update: EventUpdateDataInput!
  create: EventCreateInput!
}

input EventUpsertWithWhereUniqueNestedInput {
  where: EventWhereUniqueInput!
  update: EventUpdateDataInput!
  create: EventCreateInput!
}

input EventUpsertWithWhereUniqueWithoutLocationInput {
  where: EventWhereUniqueInput!
  update: EventUpdateWithoutLocationDataInput!
  create: EventCreateWithoutLocationInput!
}

input EventWhereInput {
  """Logical AND on all given filters."""
  AND: [EventWhereInput!]

  """Logical OR on all given filters."""
  OR: [EventWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [EventWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  date: DateTime

  """All values that are not equal to given value."""
  date_not: DateTime

  """All values that are contained in given list."""
  date_in: [DateTime!]

  """All values that are not contained in given list."""
  date_not_in: [DateTime!]

  """All values less than the given value."""
  date_lt: DateTime

  """All values less than or equal the given value."""
  date_lte: DateTime

  """All values greater than the given value."""
  date_gt: DateTime

  """All values greater than or equal the given value."""
  date_gte: DateTime
  type: EventType

  """All values that are not equal to given value."""
  type_not: EventType

  """All values that are contained in given list."""
  type_in: [EventType!]

  """All values that are not contained in given list."""
  type_not_in: [EventType!]
  description: String

  """All values that are not equal to given value."""
  description_not: String

  """All values that are contained in given list."""
  description_in: [String!]

  """All values that are not contained in given list."""
  description_not_in: [String!]

  """All values less than the given value."""
  description_lt: String

  """All values less than or equal the given value."""
  description_lte: String

  """All values greater than the given value."""
  description_gt: String

  """All values greater than or equal the given value."""
  description_gte: String

  """All values containing the given string."""
  description_contains: String

  """All values not containing the given string."""
  description_not_contains: String

  """All values starting with the given string."""
  description_starts_with: String

  """All values not starting with the given string."""
  description_not_starts_with: String

  """All values ending with the given string."""
  description_ends_with: String

  """All values not ending with the given string."""
  description_not_ends_with: String
  location: LocationWhereInput
  with_every: HumanWhereInput
  with_some: HumanWhereInput
  with_none: HumanWhereInput
}

input EventWhereUniqueInput {
  id: ID
}

type Favorite implements Node {
  id: ID!
  kind: FavoriteKind!
  thing: ID!
}

"""A connection to a list of items."""
type FavoriteConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [FavoriteEdge]!
  aggregate: AggregateFavorite!
}

input FavoriteCreateInput {
  kind: FavoriteKind!
  thing: ID!
}

input FavoriteCreateManyInput {
  create: [FavoriteCreateInput!]
  connect: [FavoriteWhereUniqueInput!]
}

"""An edge in a connection."""
type FavoriteEdge {
  """The item at the end of the edge."""
  node: Favorite!

  """A cursor for use in pagination."""
  cursor: String!
}

enum FavoriteKind {
  COLOR
  FLOWER
  MOVIE
  BOOK
  SONG
  MUSIC_ALBUM
}

enum FavoriteOrderByInput {
  id_ASC
  id_DESC
  kind_ASC
  kind_DESC
  thing_ASC
  thing_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type FavoritePreviousValues {
  id: ID!
  kind: FavoriteKind!
  thing: ID!
}

type FavoriteSubscriptionPayload {
  mutation: MutationType!
  node: Favorite
  updatedFields: [String!]
  previousValues: FavoritePreviousValues
}

input FavoriteSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [FavoriteSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [FavoriteSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [FavoriteSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: FavoriteWhereInput
}

input FavoriteUpdateDataInput {
  kind: FavoriteKind
  thing: ID
}

input FavoriteUpdateInput {
  kind: FavoriteKind
  thing: ID
}

input FavoriteUpdateManyInput {
  create: [FavoriteCreateInput!]
  connect: [FavoriteWhereUniqueInput!]
  disconnect: [FavoriteWhereUniqueInput!]
  delete: [FavoriteWhereUniqueInput!]
  update: [FavoriteUpdateWithWhereUniqueNestedInput!]
  upsert: [FavoriteUpsertWithWhereUniqueNestedInput!]
}

input FavoriteUpdateWithWhereUniqueNestedInput {
  where: FavoriteWhereUniqueInput!
  data: FavoriteUpdateDataInput!
}

input FavoriteUpsertWithWhereUniqueNestedInput {
  where: FavoriteWhereUniqueInput!
  update: FavoriteUpdateDataInput!
  create: FavoriteCreateInput!
}

input FavoriteWhereInput {
  """Logical AND on all given filters."""
  AND: [FavoriteWhereInput!]

  """Logical OR on all given filters."""
  OR: [FavoriteWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [FavoriteWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  kind: FavoriteKind

  """All values that are not equal to given value."""
  kind_not: FavoriteKind

  """All values that are contained in given list."""
  kind_in: [FavoriteKind!]

  """All values that are not contained in given list."""
  kind_not_in: [FavoriteKind!]
  thing: ID

  """All values that are not equal to given value."""
  thing_not: ID

  """All values that are contained in given list."""
  thing_in: [ID!]

  """All values that are not contained in given list."""
  thing_not_in: [ID!]

  """All values less than the given value."""
  thing_lt: ID

  """All values less than or equal the given value."""
  thing_lte: ID

  """All values greater than the given value."""
  thing_gt: ID

  """All values greater than or equal the given value."""
  thing_gte: ID

  """All values containing the given string."""
  thing_contains: ID

  """All values not containing the given string."""
  thing_not_contains: ID

  """All values starting with the given string."""
  thing_starts_with: ID

  """All values not starting with the given string."""
  thing_not_starts_with: ID

  """All values ending with the given string."""
  thing_ends_with: ID

  """All values not ending with the given string."""
  thing_not_ends_with: ID
}

input FavoriteWhereUniqueInput {
  id: ID
}

type FinanceGoals implements Node {
  id: ID!
  name: String!
  cost: Float
  due: DateTime
}

"""A connection to a list of items."""
type FinanceGoalsConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [FinanceGoalsEdge]!
  aggregate: AggregateFinanceGoals!
}

input FinanceGoalsCreateInput {
  name: String!
  cost: Float
  due: DateTime
}

input FinanceGoalsCreateManyInput {
  create: [FinanceGoalsCreateInput!]
  connect: [FinanceGoalsWhereUniqueInput!]
}

"""An edge in a connection."""
type FinanceGoalsEdge {
  """The item at the end of the edge."""
  node: FinanceGoals!

  """A cursor for use in pagination."""
  cursor: String!
}

enum FinanceGoalsOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  cost_ASC
  cost_DESC
  due_ASC
  due_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type FinanceGoalsPreviousValues {
  id: ID!
  name: String!
  cost: Float
  due: DateTime
}

type FinanceGoalsSubscriptionPayload {
  mutation: MutationType!
  node: FinanceGoals
  updatedFields: [String!]
  previousValues: FinanceGoalsPreviousValues
}

input FinanceGoalsSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [FinanceGoalsSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [FinanceGoalsSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [FinanceGoalsSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: FinanceGoalsWhereInput
}

input FinanceGoalsUpdateDataInput {
  name: String
  cost: Float
  due: DateTime
}

input FinanceGoalsUpdateInput {
  name: String
  cost: Float
  due: DateTime
}

input FinanceGoalsUpdateManyInput {
  create: [FinanceGoalsCreateInput!]
  connect: [FinanceGoalsWhereUniqueInput!]
  disconnect: [FinanceGoalsWhereUniqueInput!]
  delete: [FinanceGoalsWhereUniqueInput!]
  update: [FinanceGoalsUpdateWithWhereUniqueNestedInput!]
  upsert: [FinanceGoalsUpsertWithWhereUniqueNestedInput!]
}

input FinanceGoalsUpdateWithWhereUniqueNestedInput {
  where: FinanceGoalsWhereUniqueInput!
  data: FinanceGoalsUpdateDataInput!
}

input FinanceGoalsUpsertWithWhereUniqueNestedInput {
  where: FinanceGoalsWhereUniqueInput!
  update: FinanceGoalsUpdateDataInput!
  create: FinanceGoalsCreateInput!
}

input FinanceGoalsWhereInput {
  """Logical AND on all given filters."""
  AND: [FinanceGoalsWhereInput!]

  """Logical OR on all given filters."""
  OR: [FinanceGoalsWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [FinanceGoalsWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  name: String

  """All values that are not equal to given value."""
  name_not: String

  """All values that are contained in given list."""
  name_in: [String!]

  """All values that are not contained in given list."""
  name_not_in: [String!]

  """All values less than the given value."""
  name_lt: String

  """All values less than or equal the given value."""
  name_lte: String

  """All values greater than the given value."""
  name_gt: String

  """All values greater than or equal the given value."""
  name_gte: String

  """All values containing the given string."""
  name_contains: String

  """All values not containing the given string."""
  name_not_contains: String

  """All values starting with the given string."""
  name_starts_with: String

  """All values not starting with the given string."""
  name_not_starts_with: String

  """All values ending with the given string."""
  name_ends_with: String

  """All values not ending with the given string."""
  name_not_ends_with: String
  cost: Float

  """All values that are not equal to given value."""
  cost_not: Float

  """All values that are contained in given list."""
  cost_in: [Float!]

  """All values that are not contained in given list."""
  cost_not_in: [Float!]

  """All values less than the given value."""
  cost_lt: Float

  """All values less than or equal the given value."""
  cost_lte: Float

  """All values greater than the given value."""
  cost_gt: Float

  """All values greater than or equal the given value."""
  cost_gte: Float
  due: DateTime

  """All values that are not equal to given value."""
  due_not: DateTime

  """All values that are contained in given list."""
  due_in: [DateTime!]

  """All values that are not contained in given list."""
  due_not_in: [DateTime!]

  """All values less than the given value."""
  due_lt: DateTime

  """All values less than or equal the given value."""
  due_lte: DateTime

  """All values greater than the given value."""
  due_gt: DateTime

  """All values greater than or equal the given value."""
  due_gte: DateTime
}

input FinanceGoalsWhereUniqueInput {
  id: ID
}

type FixedCost implements Node {
  id: ID!
  name: String
  amount: Float
  type: FixedCostType
}

"""A connection to a list of items."""
type FixedCostConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [FixedCostEdge]!
  aggregate: AggregateFixedCost!
}

input FixedCostCreateInput {
  name: String
  amount: Float
  type: FixedCostType
}

input FixedCostCreateManyInput {
  create: [FixedCostCreateInput!]
  connect: [FixedCostWhereUniqueInput!]
}

"""An edge in a connection."""
type FixedCostEdge {
  """The item at the end of the edge."""
  node: FixedCost!

  """A cursor for use in pagination."""
  cursor: String!
}

enum FixedCostOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  amount_ASC
  amount_DESC
  type_ASC
  type_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type FixedCostPreviousValues {
  id: ID!
  name: String
  amount: Float
  type: FixedCostType
}

type FixedCostSubscriptionPayload {
  mutation: MutationType!
  node: FixedCost
  updatedFields: [String!]
  previousValues: FixedCostPreviousValues
}

input FixedCostSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [FixedCostSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [FixedCostSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [FixedCostSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: FixedCostWhereInput
}

enum FixedCostType {
  MONTHLY
  DAILY
  YEARLY
  WEEKLY
}

input FixedCostUpdateDataInput {
  name: String
  amount: Float
  type: FixedCostType
}

input FixedCostUpdateInput {
  name: String
  amount: Float
  type: FixedCostType
}

input FixedCostUpdateManyInput {
  create: [FixedCostCreateInput!]
  connect: [FixedCostWhereUniqueInput!]
  disconnect: [FixedCostWhereUniqueInput!]
  delete: [FixedCostWhereUniqueInput!]
  update: [FixedCostUpdateWithWhereUniqueNestedInput!]
  upsert: [FixedCostUpsertWithWhereUniqueNestedInput!]
}

input FixedCostUpdateWithWhereUniqueNestedInput {
  where: FixedCostWhereUniqueInput!
  data: FixedCostUpdateDataInput!
}

input FixedCostUpsertWithWhereUniqueNestedInput {
  where: FixedCostWhereUniqueInput!
  update: FixedCostUpdateDataInput!
  create: FixedCostCreateInput!
}

input FixedCostWhereInput {
  """Logical AND on all given filters."""
  AND: [FixedCostWhereInput!]

  """Logical OR on all given filters."""
  OR: [FixedCostWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [FixedCostWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  name: String

  """All values that are not equal to given value."""
  name_not: String

  """All values that are contained in given list."""
  name_in: [String!]

  """All values that are not contained in given list."""
  name_not_in: [String!]

  """All values less than the given value."""
  name_lt: String

  """All values less than or equal the given value."""
  name_lte: String

  """All values greater than the given value."""
  name_gt: String

  """All values greater than or equal the given value."""
  name_gte: String

  """All values containing the given string."""
  name_contains: String

  """All values not containing the given string."""
  name_not_contains: String

  """All values starting with the given string."""
  name_starts_with: String

  """All values not starting with the given string."""
  name_not_starts_with: String

  """All values ending with the given string."""
  name_ends_with: String

  """All values not ending with the given string."""
  name_not_ends_with: String
  amount: Float

  """All values that are not equal to given value."""
  amount_not: Float

  """All values that are contained in given list."""
  amount_in: [Float!]

  """All values that are not contained in given list."""
  amount_not_in: [Float!]

  """All values less than the given value."""
  amount_lt: Float

  """All values less than or equal the given value."""
  amount_lte: Float

  """All values greater than the given value."""
  amount_gt: Float

  """All values greater than or equal the given value."""
  amount_gte: Float
  type: FixedCostType

  """All values that are not equal to given value."""
  type_not: FixedCostType

  """All values that are contained in given list."""
  type_in: [FixedCostType!]

  """All values that are not contained in given list."""
  type_not_in: [FixedCostType!]
}

input FixedCostWhereUniqueInput {
  id: ID
}

type GoodOrService implements Node {
  id: ID!
  type: String
  name: String
  brand: String!
  price: Float!
  url: String
  purchased: Boolean!
  transaction(where: TransactionWhereInput): Transaction
}

"""A connection to a list of items."""
type GoodOrServiceConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [GoodOrServiceEdge]!
  aggregate: AggregateGoodOrService!
}

input GoodOrServiceCreateInput {
  type: String
  name: String
  brand: String!
  price: Float!
  url: String
  purchased: Boolean
  transaction: TransactionCreateOneWithoutItemsInput
}

input GoodOrServiceCreateManyInput {
  create: [GoodOrServiceCreateInput!]
  connect: [GoodOrServiceWhereUniqueInput!]
}

input GoodOrServiceCreateManyWithoutTransactionInput {
  create: [GoodOrServiceCreateWithoutTransactionInput!]
  connect: [GoodOrServiceWhereUniqueInput!]
}

input GoodOrServiceCreateWithoutTransactionInput {
  type: String
  name: String
  brand: String!
  price: Float!
  url: String
  purchased: Boolean
}

"""An edge in a connection."""
type GoodOrServiceEdge {
  """The item at the end of the edge."""
  node: GoodOrService!

  """A cursor for use in pagination."""
  cursor: String!
}

enum GoodOrServiceOrderByInput {
  id_ASC
  id_DESC
  type_ASC
  type_DESC
  name_ASC
  name_DESC
  brand_ASC
  brand_DESC
  price_ASC
  price_DESC
  url_ASC
  url_DESC
  purchased_ASC
  purchased_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type GoodOrServicePreviousValues {
  id: ID!
  type: String
  name: String
  brand: String!
  price: Float!
  url: String
  purchased: Boolean!
}

type GoodOrServiceSubscriptionPayload {
  mutation: MutationType!
  node: GoodOrService
  updatedFields: [String!]
  previousValues: GoodOrServicePreviousValues
}

input GoodOrServiceSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [GoodOrServiceSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [GoodOrServiceSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [GoodOrServiceSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: GoodOrServiceWhereInput
}

input GoodOrServiceUpdateDataInput {
  type: String
  name: String
  brand: String
  price: Float
  url: String
  purchased: Boolean
  transaction: TransactionUpdateOneWithoutItemsInput
}

input GoodOrServiceUpdateInput {
  type: String
  name: String
  brand: String
  price: Float
  url: String
  purchased: Boolean
  transaction: TransactionUpdateOneWithoutItemsInput
}

input GoodOrServiceUpdateManyInput {
  create: [GoodOrServiceCreateInput!]
  connect: [GoodOrServiceWhereUniqueInput!]
  disconnect: [GoodOrServiceWhereUniqueInput!]
  delete: [GoodOrServiceWhereUniqueInput!]
  update: [GoodOrServiceUpdateWithWhereUniqueNestedInput!]
  upsert: [GoodOrServiceUpsertWithWhereUniqueNestedInput!]
}

input GoodOrServiceUpdateManyWithoutTransactionInput {
  create: [GoodOrServiceCreateWithoutTransactionInput!]
  connect: [GoodOrServiceWhereUniqueInput!]
  disconnect: [GoodOrServiceWhereUniqueInput!]
  delete: [GoodOrServiceWhereUniqueInput!]
  update: [GoodOrServiceUpdateWithWhereUniqueWithoutTransactionInput!]
  upsert: [GoodOrServiceUpsertWithWhereUniqueWithoutTransactionInput!]
}

input GoodOrServiceUpdateWithoutTransactionDataInput {
  type: String
  name: String
  brand: String
  price: Float
  url: String
  purchased: Boolean
}

input GoodOrServiceUpdateWithWhereUniqueNestedInput {
  where: GoodOrServiceWhereUniqueInput!
  data: GoodOrServiceUpdateDataInput!
}

input GoodOrServiceUpdateWithWhereUniqueWithoutTransactionInput {
  where: GoodOrServiceWhereUniqueInput!
  data: GoodOrServiceUpdateWithoutTransactionDataInput!
}

input GoodOrServiceUpsertWithWhereUniqueNestedInput {
  where: GoodOrServiceWhereUniqueInput!
  update: GoodOrServiceUpdateDataInput!
  create: GoodOrServiceCreateInput!
}

input GoodOrServiceUpsertWithWhereUniqueWithoutTransactionInput {
  where: GoodOrServiceWhereUniqueInput!
  update: GoodOrServiceUpdateWithoutTransactionDataInput!
  create: GoodOrServiceCreateWithoutTransactionInput!
}

input GoodOrServiceWhereInput {
  """Logical AND on all given filters."""
  AND: [GoodOrServiceWhereInput!]

  """Logical OR on all given filters."""
  OR: [GoodOrServiceWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [GoodOrServiceWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  type: String

  """All values that are not equal to given value."""
  type_not: String

  """All values that are contained in given list."""
  type_in: [String!]

  """All values that are not contained in given list."""
  type_not_in: [String!]

  """All values less than the given value."""
  type_lt: String

  """All values less than or equal the given value."""
  type_lte: String

  """All values greater than the given value."""
  type_gt: String

  """All values greater than or equal the given value."""
  type_gte: String

  """All values containing the given string."""
  type_contains: String

  """All values not containing the given string."""
  type_not_contains: String

  """All values starting with the given string."""
  type_starts_with: String

  """All values not starting with the given string."""
  type_not_starts_with: String

  """All values ending with the given string."""
  type_ends_with: String

  """All values not ending with the given string."""
  type_not_ends_with: String
  name: String

  """All values that are not equal to given value."""
  name_not: String

  """All values that are contained in given list."""
  name_in: [String!]

  """All values that are not contained in given list."""
  name_not_in: [String!]

  """All values less than the given value."""
  name_lt: String

  """All values less than or equal the given value."""
  name_lte: String

  """All values greater than the given value."""
  name_gt: String

  """All values greater than or equal the given value."""
  name_gte: String

  """All values containing the given string."""
  name_contains: String

  """All values not containing the given string."""
  name_not_contains: String

  """All values starting with the given string."""
  name_starts_with: String

  """All values not starting with the given string."""
  name_not_starts_with: String

  """All values ending with the given string."""
  name_ends_with: String

  """All values not ending with the given string."""
  name_not_ends_with: String
  brand: String

  """All values that are not equal to given value."""
  brand_not: String

  """All values that are contained in given list."""
  brand_in: [String!]

  """All values that are not contained in given list."""
  brand_not_in: [String!]

  """All values less than the given value."""
  brand_lt: String

  """All values less than or equal the given value."""
  brand_lte: String

  """All values greater than the given value."""
  brand_gt: String

  """All values greater than or equal the given value."""
  brand_gte: String

  """All values containing the given string."""
  brand_contains: String

  """All values not containing the given string."""
  brand_not_contains: String

  """All values starting with the given string."""
  brand_starts_with: String

  """All values not starting with the given string."""
  brand_not_starts_with: String

  """All values ending with the given string."""
  brand_ends_with: String

  """All values not ending with the given string."""
  brand_not_ends_with: String
  price: Float

  """All values that are not equal to given value."""
  price_not: Float

  """All values that are contained in given list."""
  price_in: [Float!]

  """All values that are not contained in given list."""
  price_not_in: [Float!]

  """All values less than the given value."""
  price_lt: Float

  """All values less than or equal the given value."""
  price_lte: Float

  """All values greater than the given value."""
  price_gt: Float

  """All values greater than or equal the given value."""
  price_gte: Float
  url: String

  """All values that are not equal to given value."""
  url_not: String

  """All values that are contained in given list."""
  url_in: [String!]

  """All values that are not contained in given list."""
  url_not_in: [String!]

  """All values less than the given value."""
  url_lt: String

  """All values less than or equal the given value."""
  url_lte: String

  """All values greater than the given value."""
  url_gt: String

  """All values greater than or equal the given value."""
  url_gte: String

  """All values containing the given string."""
  url_contains: String

  """All values not containing the given string."""
  url_not_contains: String

  """All values starting with the given string."""
  url_starts_with: String

  """All values not starting with the given string."""
  url_not_starts_with: String

  """All values ending with the given string."""
  url_ends_with: String

  """All values not ending with the given string."""
  url_not_ends_with: String
  purchased: Boolean

  """All values that are not equal to given value."""
  purchased_not: Boolean
  transaction: TransactionWhereInput
}

input GoodOrServiceWhereUniqueInput {
  id: ID
}

type Human implements Node {
  id: ID!
  first_name: String
  last_name: String
  middle_name: String
  birthday: String
  favorites(where: FavoriteWhereInput, orderBy: FavoriteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Favorite!]
  wish_list(where: GoodOrServiceWhereInput, orderBy: GoodOrServiceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [GoodOrService!]
  contact(where: ContactInfoWhereInput): ContactInfo
  education(where: EducationWhereInput): Education
  tasks(where: TaskWhereInput, orderBy: TaskOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Task!]
  tv_shows(where: TvEpisodeTransactionWhereInput, orderBy: TvEpisodeTransactionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [TvEpisodeTransaction!]
  movies(where: MovieTransactionWhereInput, orderBy: MovieTransactionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MovieTransaction!]
  books(where: BookTransactionWhereInput, orderBy: BookTransactionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BookTransaction!]
  father(where: HumanWhereInput): Human
  mother(where: HumanWhereInput): Human
  siblings(where: HumanWhereInput, orderBy: HumanOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Human!]
  aunts(where: HumanWhereInput, orderBy: HumanOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Human!]
  uncles(where: HumanWhereInput, orderBy: HumanOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Human!]
  grandparents(where: HumanWhereInput, orderBy: HumanOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Human!]
  great_grandparents(where: HumanWhereInput, orderBy: HumanOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Human!]
  friends(where: HumanWhereInput, orderBy: HumanOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Human!]
  acquaintances(where: HumanWhereInput, orderBy: HumanOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Human!]
  colleagues(where: HumanWhereInput, orderBy: HumanOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Human!]
  height: Float
  weight: Float
  weight_history(where: WeightHistoryItemWhereInput, orderBy: WeightHistoryItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [WeightHistoryItem!]
  directed(where: MovieWhereInput, orderBy: MovieOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Movie!]
  acted_in(where: MovieWhereInput, orderBy: MovieOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Movie!]
}

"""A connection to a list of items."""
type HumanConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [HumanEdge]!
  aggregate: AggregateHuman!
}

input HumanCreateInput {
  first_name: String
  last_name: String
  middle_name: String
  birthday: String
  height: Float
  weight: Float
  favorites: FavoriteCreateManyInput
  wish_list: GoodOrServiceCreateManyInput
  contact: ContactInfoCreateOneWithoutHumanInput
  education: EducationCreateOneInput
  tasks: TaskCreateManyInput
  tv_shows: TvEpisodeTransactionCreateManyWithoutHumanInput
  movies: MovieTransactionCreateManyInput
  books: BookTransactionCreateManyInput
  father: HumanCreateOneInput
  mother: HumanCreateOneInput
  siblings: HumanCreateManyInput
  aunts: HumanCreateManyInput
  uncles: HumanCreateManyInput
  grandparents: HumanCreateManyInput
  great_grandparents: HumanCreateManyInput
  friends: HumanCreateManyInput
  acquaintances: HumanCreateManyInput
  colleagues: HumanCreateManyInput
  weight_history: WeightHistoryItemCreateManyWithoutHumanInput
  directed: MovieCreateManyWithoutDirectorInput
  acted_in: MovieCreateManyWithoutActorsInput
}

input HumanCreateManyInput {
  create: [HumanCreateInput!]
  connect: [HumanWhereUniqueInput!]
}

input HumanCreateManyWithoutActed_inInput {
  create: [HumanCreateWithoutActed_inInput!]
  connect: [HumanWhereUniqueInput!]
}

input HumanCreateOneInput {
  create: HumanCreateInput
  connect: HumanWhereUniqueInput
}

input HumanCreateOneWithoutContactInput {
  create: HumanCreateWithoutContactInput
  connect: HumanWhereUniqueInput
}

input HumanCreateOneWithoutDirectedInput {
  create: HumanCreateWithoutDirectedInput
  connect: HumanWhereUniqueInput
}

input HumanCreateOneWithoutTv_showsInput {
  create: HumanCreateWithoutTv_showsInput
  connect: HumanWhereUniqueInput
}

input HumanCreateOneWithoutWeight_historyInput {
  create: HumanCreateWithoutWeight_historyInput
  connect: HumanWhereUniqueInput
}

input HumanCreateWithoutActed_inInput {
  first_name: String
  last_name: String
  middle_name: String
  birthday: String
  height: Float
  weight: Float
  favorites: FavoriteCreateManyInput
  wish_list: GoodOrServiceCreateManyInput
  contact: ContactInfoCreateOneWithoutHumanInput
  education: EducationCreateOneInput
  tasks: TaskCreateManyInput
  tv_shows: TvEpisodeTransactionCreateManyWithoutHumanInput
  movies: MovieTransactionCreateManyInput
  books: BookTransactionCreateManyInput
  father: HumanCreateOneInput
  mother: HumanCreateOneInput
  siblings: HumanCreateManyInput
  aunts: HumanCreateManyInput
  uncles: HumanCreateManyInput
  grandparents: HumanCreateManyInput
  great_grandparents: HumanCreateManyInput
  friends: HumanCreateManyInput
  acquaintances: HumanCreateManyInput
  colleagues: HumanCreateManyInput
  weight_history: WeightHistoryItemCreateManyWithoutHumanInput
  directed: MovieCreateManyWithoutDirectorInput
}

input HumanCreateWithoutContactInput {
  first_name: String
  last_name: String
  middle_name: String
  birthday: String
  height: Float
  weight: Float
  favorites: FavoriteCreateManyInput
  wish_list: GoodOrServiceCreateManyInput
  education: EducationCreateOneInput
  tasks: TaskCreateManyInput
  tv_shows: TvEpisodeTransactionCreateManyWithoutHumanInput
  movies: MovieTransactionCreateManyInput
  books: BookTransactionCreateManyInput
  father: HumanCreateOneInput
  mother: HumanCreateOneInput
  siblings: HumanCreateManyInput
  aunts: HumanCreateManyInput
  uncles: HumanCreateManyInput
  grandparents: HumanCreateManyInput
  great_grandparents: HumanCreateManyInput
  friends: HumanCreateManyInput
  acquaintances: HumanCreateManyInput
  colleagues: HumanCreateManyInput
  weight_history: WeightHistoryItemCreateManyWithoutHumanInput
  directed: MovieCreateManyWithoutDirectorInput
  acted_in: MovieCreateManyWithoutActorsInput
}

input HumanCreateWithoutDirectedInput {
  first_name: String
  last_name: String
  middle_name: String
  birthday: String
  height: Float
  weight: Float
  favorites: FavoriteCreateManyInput
  wish_list: GoodOrServiceCreateManyInput
  contact: ContactInfoCreateOneWithoutHumanInput
  education: EducationCreateOneInput
  tasks: TaskCreateManyInput
  tv_shows: TvEpisodeTransactionCreateManyWithoutHumanInput
  movies: MovieTransactionCreateManyInput
  books: BookTransactionCreateManyInput
  father: HumanCreateOneInput
  mother: HumanCreateOneInput
  siblings: HumanCreateManyInput
  aunts: HumanCreateManyInput
  uncles: HumanCreateManyInput
  grandparents: HumanCreateManyInput
  great_grandparents: HumanCreateManyInput
  friends: HumanCreateManyInput
  acquaintances: HumanCreateManyInput
  colleagues: HumanCreateManyInput
  weight_history: WeightHistoryItemCreateManyWithoutHumanInput
  acted_in: MovieCreateManyWithoutActorsInput
}

input HumanCreateWithoutTv_showsInput {
  first_name: String
  last_name: String
  middle_name: String
  birthday: String
  height: Float
  weight: Float
  favorites: FavoriteCreateManyInput
  wish_list: GoodOrServiceCreateManyInput
  contact: ContactInfoCreateOneWithoutHumanInput
  education: EducationCreateOneInput
  tasks: TaskCreateManyInput
  movies: MovieTransactionCreateManyInput
  books: BookTransactionCreateManyInput
  father: HumanCreateOneInput
  mother: HumanCreateOneInput
  siblings: HumanCreateManyInput
  aunts: HumanCreateManyInput
  uncles: HumanCreateManyInput
  grandparents: HumanCreateManyInput
  great_grandparents: HumanCreateManyInput
  friends: HumanCreateManyInput
  acquaintances: HumanCreateManyInput
  colleagues: HumanCreateManyInput
  weight_history: WeightHistoryItemCreateManyWithoutHumanInput
  directed: MovieCreateManyWithoutDirectorInput
  acted_in: MovieCreateManyWithoutActorsInput
}

input HumanCreateWithoutWeight_historyInput {
  first_name: String
  last_name: String
  middle_name: String
  birthday: String
  height: Float
  weight: Float
  favorites: FavoriteCreateManyInput
  wish_list: GoodOrServiceCreateManyInput
  contact: ContactInfoCreateOneWithoutHumanInput
  education: EducationCreateOneInput
  tasks: TaskCreateManyInput
  tv_shows: TvEpisodeTransactionCreateManyWithoutHumanInput
  movies: MovieTransactionCreateManyInput
  books: BookTransactionCreateManyInput
  father: HumanCreateOneInput
  mother: HumanCreateOneInput
  siblings: HumanCreateManyInput
  aunts: HumanCreateManyInput
  uncles: HumanCreateManyInput
  grandparents: HumanCreateManyInput
  great_grandparents: HumanCreateManyInput
  friends: HumanCreateManyInput
  acquaintances: HumanCreateManyInput
  colleagues: HumanCreateManyInput
  directed: MovieCreateManyWithoutDirectorInput
  acted_in: MovieCreateManyWithoutActorsInput
}

"""An edge in a connection."""
type HumanEdge {
  """The item at the end of the edge."""
  node: Human!

  """A cursor for use in pagination."""
  cursor: String!
}

enum HumanOrderByInput {
  id_ASC
  id_DESC
  first_name_ASC
  first_name_DESC
  last_name_ASC
  last_name_DESC
  middle_name_ASC
  middle_name_DESC
  birthday_ASC
  birthday_DESC
  height_ASC
  height_DESC
  weight_ASC
  weight_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type HumanPreviousValues {
  id: ID!
  first_name: String
  last_name: String
  middle_name: String
  birthday: String
  height: Float
  weight: Float
}

type HumanSubscriptionPayload {
  mutation: MutationType!
  node: Human
  updatedFields: [String!]
  previousValues: HumanPreviousValues
}

input HumanSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [HumanSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [HumanSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [HumanSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: HumanWhereInput
}

input HumanUpdateDataInput {
  first_name: String
  last_name: String
  middle_name: String
  birthday: String
  height: Float
  weight: Float
  favorites: FavoriteUpdateManyInput
  wish_list: GoodOrServiceUpdateManyInput
  contact: ContactInfoUpdateOneWithoutHumanInput
  education: EducationUpdateOneInput
  tasks: TaskUpdateManyInput
  tv_shows: TvEpisodeTransactionUpdateManyWithoutHumanInput
  movies: MovieTransactionUpdateManyInput
  books: BookTransactionUpdateManyInput
  father: HumanUpdateOneInput
  mother: HumanUpdateOneInput
  siblings: HumanUpdateManyInput
  aunts: HumanUpdateManyInput
  uncles: HumanUpdateManyInput
  grandparents: HumanUpdateManyInput
  great_grandparents: HumanUpdateManyInput
  friends: HumanUpdateManyInput
  acquaintances: HumanUpdateManyInput
  colleagues: HumanUpdateManyInput
  weight_history: WeightHistoryItemUpdateManyWithoutHumanInput
  directed: MovieUpdateManyWithoutDirectorInput
  acted_in: MovieUpdateManyWithoutActorsInput
}

input HumanUpdateInput {
  first_name: String
  last_name: String
  middle_name: String
  birthday: String
  height: Float
  weight: Float
  favorites: FavoriteUpdateManyInput
  wish_list: GoodOrServiceUpdateManyInput
  contact: ContactInfoUpdateOneWithoutHumanInput
  education: EducationUpdateOneInput
  tasks: TaskUpdateManyInput
  tv_shows: TvEpisodeTransactionUpdateManyWithoutHumanInput
  movies: MovieTransactionUpdateManyInput
  books: BookTransactionUpdateManyInput
  father: HumanUpdateOneInput
  mother: HumanUpdateOneInput
  siblings: HumanUpdateManyInput
  aunts: HumanUpdateManyInput
  uncles: HumanUpdateManyInput
  grandparents: HumanUpdateManyInput
  great_grandparents: HumanUpdateManyInput
  friends: HumanUpdateManyInput
  acquaintances: HumanUpdateManyInput
  colleagues: HumanUpdateManyInput
  weight_history: WeightHistoryItemUpdateManyWithoutHumanInput
  directed: MovieUpdateManyWithoutDirectorInput
  acted_in: MovieUpdateManyWithoutActorsInput
}

input HumanUpdateManyInput {
  create: [HumanCreateInput!]
  connect: [HumanWhereUniqueInput!]
  disconnect: [HumanWhereUniqueInput!]
  delete: [HumanWhereUniqueInput!]
  update: [HumanUpdateWithWhereUniqueNestedInput!]
  upsert: [HumanUpsertWithWhereUniqueNestedInput!]
}

input HumanUpdateManyWithoutActed_inInput {
  create: [HumanCreateWithoutActed_inInput!]
  connect: [HumanWhereUniqueInput!]
  disconnect: [HumanWhereUniqueInput!]
  delete: [HumanWhereUniqueInput!]
  update: [HumanUpdateWithWhereUniqueWithoutActed_inInput!]
  upsert: [HumanUpsertWithWhereUniqueWithoutActed_inInput!]
}

input HumanUpdateOneInput {
  create: HumanCreateInput
  connect: HumanWhereUniqueInput
  disconnect: Boolean
  delete: Boolean
  update: HumanUpdateDataInput
  upsert: HumanUpsertNestedInput
}

input HumanUpdateOneWithoutContactInput {
  create: HumanCreateWithoutContactInput
  connect: HumanWhereUniqueInput
  delete: Boolean
  update: HumanUpdateWithoutContactDataInput
  upsert: HumanUpsertWithoutContactInput
}

input HumanUpdateOneWithoutDirectedInput {
  create: HumanCreateWithoutDirectedInput
  connect: HumanWhereUniqueInput
  disconnect: Boolean
  delete: Boolean
  update: HumanUpdateWithoutDirectedDataInput
  upsert: HumanUpsertWithoutDirectedInput
}

input HumanUpdateOneWithoutTv_showsInput {
  create: HumanCreateWithoutTv_showsInput
  connect: HumanWhereUniqueInput
  delete: Boolean
  update: HumanUpdateWithoutTv_showsDataInput
  upsert: HumanUpsertWithoutTv_showsInput
}

input HumanUpdateOneWithoutWeight_historyInput {
  create: HumanCreateWithoutWeight_historyInput
  connect: HumanWhereUniqueInput
  delete: Boolean
  update: HumanUpdateWithoutWeight_historyDataInput
  upsert: HumanUpsertWithoutWeight_historyInput
}

input HumanUpdateWithoutActed_inDataInput {
  first_name: String
  last_name: String
  middle_name: String
  birthday: String
  height: Float
  weight: Float
  favorites: FavoriteUpdateManyInput
  wish_list: GoodOrServiceUpdateManyInput
  contact: ContactInfoUpdateOneWithoutHumanInput
  education: EducationUpdateOneInput
  tasks: TaskUpdateManyInput
  tv_shows: TvEpisodeTransactionUpdateManyWithoutHumanInput
  movies: MovieTransactionUpdateManyInput
  books: BookTransactionUpdateManyInput
  father: HumanUpdateOneInput
  mother: HumanUpdateOneInput
  siblings: HumanUpdateManyInput
  aunts: HumanUpdateManyInput
  uncles: HumanUpdateManyInput
  grandparents: HumanUpdateManyInput
  great_grandparents: HumanUpdateManyInput
  friends: HumanUpdateManyInput
  acquaintances: HumanUpdateManyInput
  colleagues: HumanUpdateManyInput
  weight_history: WeightHistoryItemUpdateManyWithoutHumanInput
  directed: MovieUpdateManyWithoutDirectorInput
}

input HumanUpdateWithoutContactDataInput {
  first_name: String
  last_name: String
  middle_name: String
  birthday: String
  height: Float
  weight: Float
  favorites: FavoriteUpdateManyInput
  wish_list: GoodOrServiceUpdateManyInput
  education: EducationUpdateOneInput
  tasks: TaskUpdateManyInput
  tv_shows: TvEpisodeTransactionUpdateManyWithoutHumanInput
  movies: MovieTransactionUpdateManyInput
  books: BookTransactionUpdateManyInput
  father: HumanUpdateOneInput
  mother: HumanUpdateOneInput
  siblings: HumanUpdateManyInput
  aunts: HumanUpdateManyInput
  uncles: HumanUpdateManyInput
  grandparents: HumanUpdateManyInput
  great_grandparents: HumanUpdateManyInput
  friends: HumanUpdateManyInput
  acquaintances: HumanUpdateManyInput
  colleagues: HumanUpdateManyInput
  weight_history: WeightHistoryItemUpdateManyWithoutHumanInput
  directed: MovieUpdateManyWithoutDirectorInput
  acted_in: MovieUpdateManyWithoutActorsInput
}

input HumanUpdateWithoutDirectedDataInput {
  first_name: String
  last_name: String
  middle_name: String
  birthday: String
  height: Float
  weight: Float
  favorites: FavoriteUpdateManyInput
  wish_list: GoodOrServiceUpdateManyInput
  contact: ContactInfoUpdateOneWithoutHumanInput
  education: EducationUpdateOneInput
  tasks: TaskUpdateManyInput
  tv_shows: TvEpisodeTransactionUpdateManyWithoutHumanInput
  movies: MovieTransactionUpdateManyInput
  books: BookTransactionUpdateManyInput
  father: HumanUpdateOneInput
  mother: HumanUpdateOneInput
  siblings: HumanUpdateManyInput
  aunts: HumanUpdateManyInput
  uncles: HumanUpdateManyInput
  grandparents: HumanUpdateManyInput
  great_grandparents: HumanUpdateManyInput
  friends: HumanUpdateManyInput
  acquaintances: HumanUpdateManyInput
  colleagues: HumanUpdateManyInput
  weight_history: WeightHistoryItemUpdateManyWithoutHumanInput
  acted_in: MovieUpdateManyWithoutActorsInput
}

input HumanUpdateWithoutTv_showsDataInput {
  first_name: String
  last_name: String
  middle_name: String
  birthday: String
  height: Float
  weight: Float
  favorites: FavoriteUpdateManyInput
  wish_list: GoodOrServiceUpdateManyInput
  contact: ContactInfoUpdateOneWithoutHumanInput
  education: EducationUpdateOneInput
  tasks: TaskUpdateManyInput
  movies: MovieTransactionUpdateManyInput
  books: BookTransactionUpdateManyInput
  father: HumanUpdateOneInput
  mother: HumanUpdateOneInput
  siblings: HumanUpdateManyInput
  aunts: HumanUpdateManyInput
  uncles: HumanUpdateManyInput
  grandparents: HumanUpdateManyInput
  great_grandparents: HumanUpdateManyInput
  friends: HumanUpdateManyInput
  acquaintances: HumanUpdateManyInput
  colleagues: HumanUpdateManyInput
  weight_history: WeightHistoryItemUpdateManyWithoutHumanInput
  directed: MovieUpdateManyWithoutDirectorInput
  acted_in: MovieUpdateManyWithoutActorsInput
}

input HumanUpdateWithoutWeight_historyDataInput {
  first_name: String
  last_name: String
  middle_name: String
  birthday: String
  height: Float
  weight: Float
  favorites: FavoriteUpdateManyInput
  wish_list: GoodOrServiceUpdateManyInput
  contact: ContactInfoUpdateOneWithoutHumanInput
  education: EducationUpdateOneInput
  tasks: TaskUpdateManyInput
  tv_shows: TvEpisodeTransactionUpdateManyWithoutHumanInput
  movies: MovieTransactionUpdateManyInput
  books: BookTransactionUpdateManyInput
  father: HumanUpdateOneInput
  mother: HumanUpdateOneInput
  siblings: HumanUpdateManyInput
  aunts: HumanUpdateManyInput
  uncles: HumanUpdateManyInput
  grandparents: HumanUpdateManyInput
  great_grandparents: HumanUpdateManyInput
  friends: HumanUpdateManyInput
  acquaintances: HumanUpdateManyInput
  colleagues: HumanUpdateManyInput
  directed: MovieUpdateManyWithoutDirectorInput
  acted_in: MovieUpdateManyWithoutActorsInput
}

input HumanUpdateWithWhereUniqueNestedInput {
  where: HumanWhereUniqueInput!
  data: HumanUpdateDataInput!
}

input HumanUpdateWithWhereUniqueWithoutActed_inInput {
  where: HumanWhereUniqueInput!
  data: HumanUpdateWithoutActed_inDataInput!
}

input HumanUpsertNestedInput {
  update: HumanUpdateDataInput!
  create: HumanCreateInput!
}

input HumanUpsertWithoutContactInput {
  update: HumanUpdateWithoutContactDataInput!
  create: HumanCreateWithoutContactInput!
}

input HumanUpsertWithoutDirectedInput {
  update: HumanUpdateWithoutDirectedDataInput!
  create: HumanCreateWithoutDirectedInput!
}

input HumanUpsertWithoutTv_showsInput {
  update: HumanUpdateWithoutTv_showsDataInput!
  create: HumanCreateWithoutTv_showsInput!
}

input HumanUpsertWithoutWeight_historyInput {
  update: HumanUpdateWithoutWeight_historyDataInput!
  create: HumanCreateWithoutWeight_historyInput!
}

input HumanUpsertWithWhereUniqueNestedInput {
  where: HumanWhereUniqueInput!
  update: HumanUpdateDataInput!
  create: HumanCreateInput!
}

input HumanUpsertWithWhereUniqueWithoutActed_inInput {
  where: HumanWhereUniqueInput!
  update: HumanUpdateWithoutActed_inDataInput!
  create: HumanCreateWithoutActed_inInput!
}

input HumanWhereInput {
  """Logical AND on all given filters."""
  AND: [HumanWhereInput!]

  """Logical OR on all given filters."""
  OR: [HumanWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [HumanWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  first_name: String

  """All values that are not equal to given value."""
  first_name_not: String

  """All values that are contained in given list."""
  first_name_in: [String!]

  """All values that are not contained in given list."""
  first_name_not_in: [String!]

  """All values less than the given value."""
  first_name_lt: String

  """All values less than or equal the given value."""
  first_name_lte: String

  """All values greater than the given value."""
  first_name_gt: String

  """All values greater than or equal the given value."""
  first_name_gte: String

  """All values containing the given string."""
  first_name_contains: String

  """All values not containing the given string."""
  first_name_not_contains: String

  """All values starting with the given string."""
  first_name_starts_with: String

  """All values not starting with the given string."""
  first_name_not_starts_with: String

  """All values ending with the given string."""
  first_name_ends_with: String

  """All values not ending with the given string."""
  first_name_not_ends_with: String
  last_name: String

  """All values that are not equal to given value."""
  last_name_not: String

  """All values that are contained in given list."""
  last_name_in: [String!]

  """All values that are not contained in given list."""
  last_name_not_in: [String!]

  """All values less than the given value."""
  last_name_lt: String

  """All values less than or equal the given value."""
  last_name_lte: String

  """All values greater than the given value."""
  last_name_gt: String

  """All values greater than or equal the given value."""
  last_name_gte: String

  """All values containing the given string."""
  last_name_contains: String

  """All values not containing the given string."""
  last_name_not_contains: String

  """All values starting with the given string."""
  last_name_starts_with: String

  """All values not starting with the given string."""
  last_name_not_starts_with: String

  """All values ending with the given string."""
  last_name_ends_with: String

  """All values not ending with the given string."""
  last_name_not_ends_with: String
  middle_name: String

  """All values that are not equal to given value."""
  middle_name_not: String

  """All values that are contained in given list."""
  middle_name_in: [String!]

  """All values that are not contained in given list."""
  middle_name_not_in: [String!]

  """All values less than the given value."""
  middle_name_lt: String

  """All values less than or equal the given value."""
  middle_name_lte: String

  """All values greater than the given value."""
  middle_name_gt: String

  """All values greater than or equal the given value."""
  middle_name_gte: String

  """All values containing the given string."""
  middle_name_contains: String

  """All values not containing the given string."""
  middle_name_not_contains: String

  """All values starting with the given string."""
  middle_name_starts_with: String

  """All values not starting with the given string."""
  middle_name_not_starts_with: String

  """All values ending with the given string."""
  middle_name_ends_with: String

  """All values not ending with the given string."""
  middle_name_not_ends_with: String
  birthday: String

  """All values that are not equal to given value."""
  birthday_not: String

  """All values that are contained in given list."""
  birthday_in: [String!]

  """All values that are not contained in given list."""
  birthday_not_in: [String!]

  """All values less than the given value."""
  birthday_lt: String

  """All values less than or equal the given value."""
  birthday_lte: String

  """All values greater than the given value."""
  birthday_gt: String

  """All values greater than or equal the given value."""
  birthday_gte: String

  """All values containing the given string."""
  birthday_contains: String

  """All values not containing the given string."""
  birthday_not_contains: String

  """All values starting with the given string."""
  birthday_starts_with: String

  """All values not starting with the given string."""
  birthday_not_starts_with: String

  """All values ending with the given string."""
  birthday_ends_with: String

  """All values not ending with the given string."""
  birthday_not_ends_with: String
  height: Float

  """All values that are not equal to given value."""
  height_not: Float

  """All values that are contained in given list."""
  height_in: [Float!]

  """All values that are not contained in given list."""
  height_not_in: [Float!]

  """All values less than the given value."""
  height_lt: Float

  """All values less than or equal the given value."""
  height_lte: Float

  """All values greater than the given value."""
  height_gt: Float

  """All values greater than or equal the given value."""
  height_gte: Float
  weight: Float

  """All values that are not equal to given value."""
  weight_not: Float

  """All values that are contained in given list."""
  weight_in: [Float!]

  """All values that are not contained in given list."""
  weight_not_in: [Float!]

  """All values less than the given value."""
  weight_lt: Float

  """All values less than or equal the given value."""
  weight_lte: Float

  """All values greater than the given value."""
  weight_gt: Float

  """All values greater than or equal the given value."""
  weight_gte: Float
  favorites_every: FavoriteWhereInput
  favorites_some: FavoriteWhereInput
  favorites_none: FavoriteWhereInput
  wish_list_every: GoodOrServiceWhereInput
  wish_list_some: GoodOrServiceWhereInput
  wish_list_none: GoodOrServiceWhereInput
  contact: ContactInfoWhereInput
  education: EducationWhereInput
  tasks_every: TaskWhereInput
  tasks_some: TaskWhereInput
  tasks_none: TaskWhereInput
  tv_shows_every: TvEpisodeTransactionWhereInput
  tv_shows_some: TvEpisodeTransactionWhereInput
  tv_shows_none: TvEpisodeTransactionWhereInput
  movies_every: MovieTransactionWhereInput
  movies_some: MovieTransactionWhereInput
  movies_none: MovieTransactionWhereInput
  books_every: BookTransactionWhereInput
  books_some: BookTransactionWhereInput
  books_none: BookTransactionWhereInput
  father: HumanWhereInput
  mother: HumanWhereInput
  siblings_every: HumanWhereInput
  siblings_some: HumanWhereInput
  siblings_none: HumanWhereInput
  aunts_every: HumanWhereInput
  aunts_some: HumanWhereInput
  aunts_none: HumanWhereInput
  uncles_every: HumanWhereInput
  uncles_some: HumanWhereInput
  uncles_none: HumanWhereInput
  grandparents_every: HumanWhereInput
  grandparents_some: HumanWhereInput
  grandparents_none: HumanWhereInput
  great_grandparents_every: HumanWhereInput
  great_grandparents_some: HumanWhereInput
  great_grandparents_none: HumanWhereInput
  friends_every: HumanWhereInput
  friends_some: HumanWhereInput
  friends_none: HumanWhereInput
  acquaintances_every: HumanWhereInput
  acquaintances_some: HumanWhereInput
  acquaintances_none: HumanWhereInput
  colleagues_every: HumanWhereInput
  colleagues_some: HumanWhereInput
  colleagues_none: HumanWhereInput
  weight_history_every: WeightHistoryItemWhereInput
  weight_history_some: WeightHistoryItemWhereInput
  weight_history_none: WeightHistoryItemWhereInput
  directed_every: MovieWhereInput
  directed_some: MovieWhereInput
  directed_none: MovieWhereInput
  acted_in_every: MovieWhereInput
  acted_in_some: MovieWhereInput
  acted_in_none: MovieWhereInput
}

input HumanWhereUniqueInput {
  id: ID
}

type Location implements Node {
  id: ID!
  longitude: Float!
  latitude: Float!
  address: String!
  type: String
  name: String!
  events(where: EventWhereInput, orderBy: EventOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Event!]
}

"""A connection to a list of items."""
type LocationConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [LocationEdge]!
  aggregate: AggregateLocation!
}

input LocationCreateInput {
  longitude: Float!
  latitude: Float!
  address: String!
  type: String
  name: String!
  events: EventCreateManyWithoutLocationInput
}

input LocationCreateOneInput {
  create: LocationCreateInput
  connect: LocationWhereUniqueInput
}

input LocationCreateOneWithoutEventsInput {
  create: LocationCreateWithoutEventsInput
  connect: LocationWhereUniqueInput
}

input LocationCreateWithoutEventsInput {
  longitude: Float!
  latitude: Float!
  address: String!
  type: String
  name: String!
}

"""An edge in a connection."""
type LocationEdge {
  """The item at the end of the edge."""
  node: Location!

  """A cursor for use in pagination."""
  cursor: String!
}

enum LocationOrderByInput {
  id_ASC
  id_DESC
  longitude_ASC
  longitude_DESC
  latitude_ASC
  latitude_DESC
  address_ASC
  address_DESC
  type_ASC
  type_DESC
  name_ASC
  name_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type LocationPreviousValues {
  id: ID!
  longitude: Float!
  latitude: Float!
  address: String!
  type: String
  name: String!
}

type LocationSubscriptionPayload {
  mutation: MutationType!
  node: Location
  updatedFields: [String!]
  previousValues: LocationPreviousValues
}

input LocationSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [LocationSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [LocationSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [LocationSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: LocationWhereInput
}

input LocationUpdateDataInput {
  longitude: Float
  latitude: Float
  address: String
  type: String
  name: String
  events: EventUpdateManyWithoutLocationInput
}

input LocationUpdateInput {
  longitude: Float
  latitude: Float
  address: String
  type: String
  name: String
  events: EventUpdateManyWithoutLocationInput
}

input LocationUpdateOneInput {
  create: LocationCreateInput
  connect: LocationWhereUniqueInput
  disconnect: Boolean
  delete: Boolean
  update: LocationUpdateDataInput
  upsert: LocationUpsertNestedInput
}

input LocationUpdateOneWithoutEventsInput {
  create: LocationCreateWithoutEventsInput
  connect: LocationWhereUniqueInput
  delete: Boolean
  update: LocationUpdateWithoutEventsDataInput
  upsert: LocationUpsertWithoutEventsInput
}

input LocationUpdateWithoutEventsDataInput {
  longitude: Float
  latitude: Float
  address: String
  type: String
  name: String
}

input LocationUpsertNestedInput {
  update: LocationUpdateDataInput!
  create: LocationCreateInput!
}

input LocationUpsertWithoutEventsInput {
  update: LocationUpdateWithoutEventsDataInput!
  create: LocationCreateWithoutEventsInput!
}

input LocationWhereInput {
  """Logical AND on all given filters."""
  AND: [LocationWhereInput!]

  """Logical OR on all given filters."""
  OR: [LocationWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [LocationWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  longitude: Float

  """All values that are not equal to given value."""
  longitude_not: Float

  """All values that are contained in given list."""
  longitude_in: [Float!]

  """All values that are not contained in given list."""
  longitude_not_in: [Float!]

  """All values less than the given value."""
  longitude_lt: Float

  """All values less than or equal the given value."""
  longitude_lte: Float

  """All values greater than the given value."""
  longitude_gt: Float

  """All values greater than or equal the given value."""
  longitude_gte: Float
  latitude: Float

  """All values that are not equal to given value."""
  latitude_not: Float

  """All values that are contained in given list."""
  latitude_in: [Float!]

  """All values that are not contained in given list."""
  latitude_not_in: [Float!]

  """All values less than the given value."""
  latitude_lt: Float

  """All values less than or equal the given value."""
  latitude_lte: Float

  """All values greater than the given value."""
  latitude_gt: Float

  """All values greater than or equal the given value."""
  latitude_gte: Float
  address: String

  """All values that are not equal to given value."""
  address_not: String

  """All values that are contained in given list."""
  address_in: [String!]

  """All values that are not contained in given list."""
  address_not_in: [String!]

  """All values less than the given value."""
  address_lt: String

  """All values less than or equal the given value."""
  address_lte: String

  """All values greater than the given value."""
  address_gt: String

  """All values greater than or equal the given value."""
  address_gte: String

  """All values containing the given string."""
  address_contains: String

  """All values not containing the given string."""
  address_not_contains: String

  """All values starting with the given string."""
  address_starts_with: String

  """All values not starting with the given string."""
  address_not_starts_with: String

  """All values ending with the given string."""
  address_ends_with: String

  """All values not ending with the given string."""
  address_not_ends_with: String
  type: String

  """All values that are not equal to given value."""
  type_not: String

  """All values that are contained in given list."""
  type_in: [String!]

  """All values that are not contained in given list."""
  type_not_in: [String!]

  """All values less than the given value."""
  type_lt: String

  """All values less than or equal the given value."""
  type_lte: String

  """All values greater than the given value."""
  type_gt: String

  """All values greater than or equal the given value."""
  type_gte: String

  """All values containing the given string."""
  type_contains: String

  """All values not containing the given string."""
  type_not_contains: String

  """All values starting with the given string."""
  type_starts_with: String

  """All values not starting with the given string."""
  type_not_starts_with: String

  """All values ending with the given string."""
  type_ends_with: String

  """All values not ending with the given string."""
  type_not_ends_with: String
  name: String

  """All values that are not equal to given value."""
  name_not: String

  """All values that are contained in given list."""
  name_in: [String!]

  """All values that are not contained in given list."""
  name_not_in: [String!]

  """All values less than the given value."""
  name_lt: String

  """All values less than or equal the given value."""
  name_lte: String

  """All values greater than the given value."""
  name_gt: String

  """All values greater than or equal the given value."""
  name_gte: String

  """All values containing the given string."""
  name_contains: String

  """All values not containing the given string."""
  name_not_contains: String

  """All values starting with the given string."""
  name_starts_with: String

  """All values not starting with the given string."""
  name_not_starts_with: String

  """All values ending with the given string."""
  name_ends_with: String

  """All values not ending with the given string."""
  name_not_ends_with: String
  events_every: EventWhereInput
  events_some: EventWhereInput
  events_none: EventWhereInput
}

input LocationWhereUniqueInput {
  id: ID
}

"""
The `Long` scalar type represents non-fractional signed whole numeric values.
Long can represent values between -(2^63) and 2^63 - 1.
"""
scalar Long

type Movie implements Node {
  id: ID!
  name: String
  category: String
  release_date: DateTime!
  director(where: HumanWhereInput): Human
  actors(where: HumanWhereInput, orderBy: HumanOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Human!]
}

"""A connection to a list of items."""
type MovieConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [MovieEdge]!
  aggregate: AggregateMovie!
}

input MovieCreateInput {
  name: String
  category: String
  release_date: DateTime!
  director: HumanCreateOneWithoutDirectedInput
  actors: HumanCreateManyWithoutActed_inInput
}

input MovieCreateManyWithoutActorsInput {
  create: [MovieCreateWithoutActorsInput!]
  connect: [MovieWhereUniqueInput!]
}

input MovieCreateManyWithoutDirectorInput {
  create: [MovieCreateWithoutDirectorInput!]
  connect: [MovieWhereUniqueInput!]
}

input MovieCreateOneInput {
  create: MovieCreateInput
  connect: MovieWhereUniqueInput
}

input MovieCreateWithoutActorsInput {
  name: String
  category: String
  release_date: DateTime!
  director: HumanCreateOneWithoutDirectedInput
}

input MovieCreateWithoutDirectorInput {
  name: String
  category: String
  release_date: DateTime!
  actors: HumanCreateManyWithoutActed_inInput
}

"""An edge in a connection."""
type MovieEdge {
  """The item at the end of the edge."""
  node: Movie!

  """A cursor for use in pagination."""
  cursor: String!
}

enum MovieOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  category_ASC
  category_DESC
  release_date_ASC
  release_date_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type MoviePreviousValues {
  id: ID!
  name: String
  category: String
  release_date: DateTime!
}

type MovieSubscriptionPayload {
  mutation: MutationType!
  node: Movie
  updatedFields: [String!]
  previousValues: MoviePreviousValues
}

input MovieSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [MovieSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [MovieSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [MovieSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: MovieWhereInput
}

type MovieTransaction implements Node {
  id: ID!
  movie(where: MovieWhereInput): Movie!
  date_watched: DateTime!
}

"""A connection to a list of items."""
type MovieTransactionConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [MovieTransactionEdge]!
  aggregate: AggregateMovieTransaction!
}

input MovieTransactionCreateInput {
  date_watched: DateTime!
  movie: MovieCreateOneInput!
}

input MovieTransactionCreateManyInput {
  create: [MovieTransactionCreateInput!]
  connect: [MovieTransactionWhereUniqueInput!]
}

"""An edge in a connection."""
type MovieTransactionEdge {
  """The item at the end of the edge."""
  node: MovieTransaction!

  """A cursor for use in pagination."""
  cursor: String!
}

enum MovieTransactionOrderByInput {
  id_ASC
  id_DESC
  date_watched_ASC
  date_watched_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type MovieTransactionPreviousValues {
  id: ID!
  date_watched: DateTime!
}

type MovieTransactionSubscriptionPayload {
  mutation: MutationType!
  node: MovieTransaction
  updatedFields: [String!]
  previousValues: MovieTransactionPreviousValues
}

input MovieTransactionSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [MovieTransactionSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [MovieTransactionSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [MovieTransactionSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: MovieTransactionWhereInput
}

input MovieTransactionUpdateDataInput {
  date_watched: DateTime
  movie: MovieUpdateOneInput
}

input MovieTransactionUpdateInput {
  date_watched: DateTime
  movie: MovieUpdateOneInput
}

input MovieTransactionUpdateManyInput {
  create: [MovieTransactionCreateInput!]
  connect: [MovieTransactionWhereUniqueInput!]
  disconnect: [MovieTransactionWhereUniqueInput!]
  delete: [MovieTransactionWhereUniqueInput!]
  update: [MovieTransactionUpdateWithWhereUniqueNestedInput!]
  upsert: [MovieTransactionUpsertWithWhereUniqueNestedInput!]
}

input MovieTransactionUpdateWithWhereUniqueNestedInput {
  where: MovieTransactionWhereUniqueInput!
  data: MovieTransactionUpdateDataInput!
}

input MovieTransactionUpsertWithWhereUniqueNestedInput {
  where: MovieTransactionWhereUniqueInput!
  update: MovieTransactionUpdateDataInput!
  create: MovieTransactionCreateInput!
}

input MovieTransactionWhereInput {
  """Logical AND on all given filters."""
  AND: [MovieTransactionWhereInput!]

  """Logical OR on all given filters."""
  OR: [MovieTransactionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [MovieTransactionWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  date_watched: DateTime

  """All values that are not equal to given value."""
  date_watched_not: DateTime

  """All values that are contained in given list."""
  date_watched_in: [DateTime!]

  """All values that are not contained in given list."""
  date_watched_not_in: [DateTime!]

  """All values less than the given value."""
  date_watched_lt: DateTime

  """All values less than or equal the given value."""
  date_watched_lte: DateTime

  """All values greater than the given value."""
  date_watched_gt: DateTime

  """All values greater than or equal the given value."""
  date_watched_gte: DateTime
  movie: MovieWhereInput
}

input MovieTransactionWhereUniqueInput {
  id: ID
}

input MovieUpdateDataInput {
  name: String
  category: String
  release_date: DateTime
  director: HumanUpdateOneWithoutDirectedInput
  actors: HumanUpdateManyWithoutActed_inInput
}

input MovieUpdateInput {
  name: String
  category: String
  release_date: DateTime
  director: HumanUpdateOneWithoutDirectedInput
  actors: HumanUpdateManyWithoutActed_inInput
}

input MovieUpdateManyWithoutActorsInput {
  create: [MovieCreateWithoutActorsInput!]
  connect: [MovieWhereUniqueInput!]
  disconnect: [MovieWhereUniqueInput!]
  delete: [MovieWhereUniqueInput!]
  update: [MovieUpdateWithWhereUniqueWithoutActorsInput!]
  upsert: [MovieUpsertWithWhereUniqueWithoutActorsInput!]
}

input MovieUpdateManyWithoutDirectorInput {
  create: [MovieCreateWithoutDirectorInput!]
  connect: [MovieWhereUniqueInput!]
  disconnect: [MovieWhereUniqueInput!]
  delete: [MovieWhereUniqueInput!]
  update: [MovieUpdateWithWhereUniqueWithoutDirectorInput!]
  upsert: [MovieUpsertWithWhereUniqueWithoutDirectorInput!]
}

input MovieUpdateOneInput {
  create: MovieCreateInput
  connect: MovieWhereUniqueInput
  delete: Boolean
  update: MovieUpdateDataInput
  upsert: MovieUpsertNestedInput
}

input MovieUpdateWithoutActorsDataInput {
  name: String
  category: String
  release_date: DateTime
  director: HumanUpdateOneWithoutDirectedInput
}

input MovieUpdateWithoutDirectorDataInput {
  name: String
  category: String
  release_date: DateTime
  actors: HumanUpdateManyWithoutActed_inInput
}

input MovieUpdateWithWhereUniqueWithoutActorsInput {
  where: MovieWhereUniqueInput!
  data: MovieUpdateWithoutActorsDataInput!
}

input MovieUpdateWithWhereUniqueWithoutDirectorInput {
  where: MovieWhereUniqueInput!
  data: MovieUpdateWithoutDirectorDataInput!
}

input MovieUpsertNestedInput {
  update: MovieUpdateDataInput!
  create: MovieCreateInput!
}

input MovieUpsertWithWhereUniqueWithoutActorsInput {
  where: MovieWhereUniqueInput!
  update: MovieUpdateWithoutActorsDataInput!
  create: MovieCreateWithoutActorsInput!
}

input MovieUpsertWithWhereUniqueWithoutDirectorInput {
  where: MovieWhereUniqueInput!
  update: MovieUpdateWithoutDirectorDataInput!
  create: MovieCreateWithoutDirectorInput!
}

input MovieWhereInput {
  """Logical AND on all given filters."""
  AND: [MovieWhereInput!]

  """Logical OR on all given filters."""
  OR: [MovieWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [MovieWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  name: String

  """All values that are not equal to given value."""
  name_not: String

  """All values that are contained in given list."""
  name_in: [String!]

  """All values that are not contained in given list."""
  name_not_in: [String!]

  """All values less than the given value."""
  name_lt: String

  """All values less than or equal the given value."""
  name_lte: String

  """All values greater than the given value."""
  name_gt: String

  """All values greater than or equal the given value."""
  name_gte: String

  """All values containing the given string."""
  name_contains: String

  """All values not containing the given string."""
  name_not_contains: String

  """All values starting with the given string."""
  name_starts_with: String

  """All values not starting with the given string."""
  name_not_starts_with: String

  """All values ending with the given string."""
  name_ends_with: String

  """All values not ending with the given string."""
  name_not_ends_with: String
  category: String

  """All values that are not equal to given value."""
  category_not: String

  """All values that are contained in given list."""
  category_in: [String!]

  """All values that are not contained in given list."""
  category_not_in: [String!]

  """All values less than the given value."""
  category_lt: String

  """All values less than or equal the given value."""
  category_lte: String

  """All values greater than the given value."""
  category_gt: String

  """All values greater than or equal the given value."""
  category_gte: String

  """All values containing the given string."""
  category_contains: String

  """All values not containing the given string."""
  category_not_contains: String

  """All values starting with the given string."""
  category_starts_with: String

  """All values not starting with the given string."""
  category_not_starts_with: String

  """All values ending with the given string."""
  category_ends_with: String

  """All values not ending with the given string."""
  category_not_ends_with: String
  release_date: DateTime

  """All values that are not equal to given value."""
  release_date_not: DateTime

  """All values that are contained in given list."""
  release_date_in: [DateTime!]

  """All values that are not contained in given list."""
  release_date_not_in: [DateTime!]

  """All values less than the given value."""
  release_date_lt: DateTime

  """All values less than or equal the given value."""
  release_date_lte: DateTime

  """All values greater than the given value."""
  release_date_gt: DateTime

  """All values greater than or equal the given value."""
  release_date_gte: DateTime
  director: HumanWhereInput
  actors_every: HumanWhereInput
  actors_some: HumanWhereInput
  actors_none: HumanWhereInput
}

input MovieWhereUniqueInput {
  id: ID
}

type Mutation {
  createCourseLecture(data: CourseLectureCreateInput!): CourseLecture!
  createCourseAssignment(data: CourseAssignmentCreateInput!): CourseAssignment!
  createTvEpisodeTransaction(data: TvEpisodeTransactionCreateInput!): TvEpisodeTransaction!
  createTimeline(data: TimelineCreateInput!): Timeline!
  createOverview(data: OverviewCreateInput!): Overview!
  createWishList(data: WishListCreateInput!): WishList!
  createContactInfo(data: ContactInfoCreateInput!): ContactInfo!
  createWeightHistoryItem(data: WeightHistoryItemCreateInput!): WeightHistoryItem!
  createTvEpisode(data: TvEpisodeCreateInput!): TvEpisode!
  createBudget(data: BudgetCreateInput!): Budget!
  createFinanceGoals(data: FinanceGoalsCreateInput!): FinanceGoals!
  createTask(data: TaskCreateInput!): Task!
  createMovie(data: MovieCreateInput!): Movie!
  createTransaction(data: TransactionCreateInput!): Transaction!
  createEducation(data: EducationCreateInput!): Education!
  createBookTransaction(data: BookTransactionCreateInput!): BookTransaction!
  createTransactionSplit(data: TransactionSplitCreateInput!): TransactionSplit!
  createBook(data: BookCreateInput!): Book!
  createCourse(data: CourseCreateInput!): Course!
  createMovieTransaction(data: MovieTransactionCreateInput!): MovieTransaction!
  createTvShow(data: TvShowCreateInput!): TvShow!
  createFavorite(data: FavoriteCreateInput!): Favorite!
  createEvent(data: EventCreateInput!): Event!
  createLocation(data: LocationCreateInput!): Location!
  createSchool(data: SchoolCreateInput!): School!
  createAccount(data: AccountCreateInput!): Account!
  createFixedCost(data: FixedCostCreateInput!): FixedCost!
  createGoodOrService(data: GoodOrServiceCreateInput!): GoodOrService!
  createHuman(data: HumanCreateInput!): Human!
  updateCourseLecture(data: CourseLectureUpdateInput!, where: CourseLectureWhereUniqueInput!): CourseLecture
  updateCourseAssignment(data: CourseAssignmentUpdateInput!, where: CourseAssignmentWhereUniqueInput!): CourseAssignment
  updateTvEpisodeTransaction(data: TvEpisodeTransactionUpdateInput!, where: TvEpisodeTransactionWhereUniqueInput!): TvEpisodeTransaction
  updateTimeline(data: TimelineUpdateInput!, where: TimelineWhereUniqueInput!): Timeline
  updateOverview(data: OverviewUpdateInput!, where: OverviewWhereUniqueInput!): Overview
  updateWeightHistoryItem(data: WeightHistoryItemUpdateInput!, where: WeightHistoryItemWhereUniqueInput!): WeightHistoryItem
  updateTvEpisode(data: TvEpisodeUpdateInput!, where: TvEpisodeWhereUniqueInput!): TvEpisode
  updateBudget(data: BudgetUpdateInput!, where: BudgetWhereUniqueInput!): Budget
  updateFinanceGoals(data: FinanceGoalsUpdateInput!, where: FinanceGoalsWhereUniqueInput!): FinanceGoals
  updateTask(data: TaskUpdateInput!, where: TaskWhereUniqueInput!): Task
  updateMovie(data: MovieUpdateInput!, where: MovieWhereUniqueInput!): Movie
  updateTransaction(data: TransactionUpdateInput!, where: TransactionWhereUniqueInput!): Transaction
  updateEducation(data: EducationUpdateInput!, where: EducationWhereUniqueInput!): Education
  updateBookTransaction(data: BookTransactionUpdateInput!, where: BookTransactionWhereUniqueInput!): BookTransaction
  updateBook(data: BookUpdateInput!, where: BookWhereUniqueInput!): Book
  updateMovieTransaction(data: MovieTransactionUpdateInput!, where: MovieTransactionWhereUniqueInput!): MovieTransaction
  updateTvShow(data: TvShowUpdateInput!, where: TvShowWhereUniqueInput!): TvShow
  updateFavorite(data: FavoriteUpdateInput!, where: FavoriteWhereUniqueInput!): Favorite
  updateEvent(data: EventUpdateInput!, where: EventWhereUniqueInput!): Event
  updateLocation(data: LocationUpdateInput!, where: LocationWhereUniqueInput!): Location
  updateSchool(data: SchoolUpdateInput!, where: SchoolWhereUniqueInput!): School
  updateAccount(data: AccountUpdateInput!, where: AccountWhereUniqueInput!): Account
  updateFixedCost(data: FixedCostUpdateInput!, where: FixedCostWhereUniqueInput!): FixedCost
  updateGoodOrService(data: GoodOrServiceUpdateInput!, where: GoodOrServiceWhereUniqueInput!): GoodOrService
  updateHuman(data: HumanUpdateInput!, where: HumanWhereUniqueInput!): Human
  deleteCourseLecture(where: CourseLectureWhereUniqueInput!): CourseLecture
  deleteCourseAssignment(where: CourseAssignmentWhereUniqueInput!): CourseAssignment
  deleteTvEpisodeTransaction(where: TvEpisodeTransactionWhereUniqueInput!): TvEpisodeTransaction
  deleteTimeline(where: TimelineWhereUniqueInput!): Timeline
  deleteOverview(where: OverviewWhereUniqueInput!): Overview
  deleteWeightHistoryItem(where: WeightHistoryItemWhereUniqueInput!): WeightHistoryItem
  deleteTvEpisode(where: TvEpisodeWhereUniqueInput!): TvEpisode
  deleteBudget(where: BudgetWhereUniqueInput!): Budget
  deleteFinanceGoals(where: FinanceGoalsWhereUniqueInput!): FinanceGoals
  deleteTask(where: TaskWhereUniqueInput!): Task
  deleteMovie(where: MovieWhereUniqueInput!): Movie
  deleteTransaction(where: TransactionWhereUniqueInput!): Transaction
  deleteEducation(where: EducationWhereUniqueInput!): Education
  deleteBookTransaction(where: BookTransactionWhereUniqueInput!): BookTransaction
  deleteBook(where: BookWhereUniqueInput!): Book
  deleteMovieTransaction(where: MovieTransactionWhereUniqueInput!): MovieTransaction
  deleteTvShow(where: TvShowWhereUniqueInput!): TvShow
  deleteFavorite(where: FavoriteWhereUniqueInput!): Favorite
  deleteEvent(where: EventWhereUniqueInput!): Event
  deleteLocation(where: LocationWhereUniqueInput!): Location
  deleteSchool(where: SchoolWhereUniqueInput!): School
  deleteAccount(where: AccountWhereUniqueInput!): Account
  deleteFixedCost(where: FixedCostWhereUniqueInput!): FixedCost
  deleteGoodOrService(where: GoodOrServiceWhereUniqueInput!): GoodOrService
  deleteHuman(where: HumanWhereUniqueInput!): Human
  upsertCourseLecture(where: CourseLectureWhereUniqueInput!, create: CourseLectureCreateInput!, update: CourseLectureUpdateInput!): CourseLecture!
  upsertCourseAssignment(where: CourseAssignmentWhereUniqueInput!, create: CourseAssignmentCreateInput!, update: CourseAssignmentUpdateInput!): CourseAssignment!
  upsertTvEpisodeTransaction(where: TvEpisodeTransactionWhereUniqueInput!, create: TvEpisodeTransactionCreateInput!, update: TvEpisodeTransactionUpdateInput!): TvEpisodeTransaction!
  upsertTimeline(where: TimelineWhereUniqueInput!, create: TimelineCreateInput!, update: TimelineUpdateInput!): Timeline!
  upsertOverview(where: OverviewWhereUniqueInput!, create: OverviewCreateInput!, update: OverviewUpdateInput!): Overview!
  upsertWeightHistoryItem(where: WeightHistoryItemWhereUniqueInput!, create: WeightHistoryItemCreateInput!, update: WeightHistoryItemUpdateInput!): WeightHistoryItem!
  upsertTvEpisode(where: TvEpisodeWhereUniqueInput!, create: TvEpisodeCreateInput!, update: TvEpisodeUpdateInput!): TvEpisode!
  upsertBudget(where: BudgetWhereUniqueInput!, create: BudgetCreateInput!, update: BudgetUpdateInput!): Budget!
  upsertFinanceGoals(where: FinanceGoalsWhereUniqueInput!, create: FinanceGoalsCreateInput!, update: FinanceGoalsUpdateInput!): FinanceGoals!
  upsertTask(where: TaskWhereUniqueInput!, create: TaskCreateInput!, update: TaskUpdateInput!): Task!
  upsertMovie(where: MovieWhereUniqueInput!, create: MovieCreateInput!, update: MovieUpdateInput!): Movie!
  upsertTransaction(where: TransactionWhereUniqueInput!, create: TransactionCreateInput!, update: TransactionUpdateInput!): Transaction!
  upsertEducation(where: EducationWhereUniqueInput!, create: EducationCreateInput!, update: EducationUpdateInput!): Education!
  upsertBookTransaction(where: BookTransactionWhereUniqueInput!, create: BookTransactionCreateInput!, update: BookTransactionUpdateInput!): BookTransaction!
  upsertBook(where: BookWhereUniqueInput!, create: BookCreateInput!, update: BookUpdateInput!): Book!
  upsertMovieTransaction(where: MovieTransactionWhereUniqueInput!, create: MovieTransactionCreateInput!, update: MovieTransactionUpdateInput!): MovieTransaction!
  upsertTvShow(where: TvShowWhereUniqueInput!, create: TvShowCreateInput!, update: TvShowUpdateInput!): TvShow!
  upsertFavorite(where: FavoriteWhereUniqueInput!, create: FavoriteCreateInput!, update: FavoriteUpdateInput!): Favorite!
  upsertEvent(where: EventWhereUniqueInput!, create: EventCreateInput!, update: EventUpdateInput!): Event!
  upsertLocation(where: LocationWhereUniqueInput!, create: LocationCreateInput!, update: LocationUpdateInput!): Location!
  upsertSchool(where: SchoolWhereUniqueInput!, create: SchoolCreateInput!, update: SchoolUpdateInput!): School!
  upsertAccount(where: AccountWhereUniqueInput!, create: AccountCreateInput!, update: AccountUpdateInput!): Account!
  upsertFixedCost(where: FixedCostWhereUniqueInput!, create: FixedCostCreateInput!, update: FixedCostUpdateInput!): FixedCost!
  upsertGoodOrService(where: GoodOrServiceWhereUniqueInput!, create: GoodOrServiceCreateInput!, update: GoodOrServiceUpdateInput!): GoodOrService!
  upsertHuman(where: HumanWhereUniqueInput!, create: HumanCreateInput!, update: HumanUpdateInput!): Human!
  updateManyCourseLectures(data: CourseLectureUpdateInput!, where: CourseLectureWhereInput): BatchPayload!
  updateManyCourseAssignments(data: CourseAssignmentUpdateInput!, where: CourseAssignmentWhereInput): BatchPayload!
  updateManyTvEpisodeTransactions(data: TvEpisodeTransactionUpdateInput!, where: TvEpisodeTransactionWhereInput): BatchPayload!
  updateManyTimelines(data: TimelineUpdateInput!, where: TimelineWhereInput): BatchPayload!
  updateManyOverviews(data: OverviewUpdateInput!, where: OverviewWhereInput): BatchPayload!
  updateManyWishLists(data: WishListUpdateInput!, where: WishListWhereInput): BatchPayload!
  updateManyContactInfoes(data: ContactInfoUpdateInput!, where: ContactInfoWhereInput): BatchPayload!
  updateManyWeightHistoryItems(data: WeightHistoryItemUpdateInput!, where: WeightHistoryItemWhereInput): BatchPayload!
  updateManyTvEpisodes(data: TvEpisodeUpdateInput!, where: TvEpisodeWhereInput): BatchPayload!
  updateManyBudgets(data: BudgetUpdateInput!, where: BudgetWhereInput): BatchPayload!
  updateManyFinanceGoalses(data: FinanceGoalsUpdateInput!, where: FinanceGoalsWhereInput): BatchPayload!
  updateManyTasks(data: TaskUpdateInput!, where: TaskWhereInput): BatchPayload!
  updateManyMovies(data: MovieUpdateInput!, where: MovieWhereInput): BatchPayload!
  updateManyTransactions(data: TransactionUpdateInput!, where: TransactionWhereInput): BatchPayload!
  updateManyEducations(data: EducationUpdateInput!, where: EducationWhereInput): BatchPayload!
  updateManyBookTransactions(data: BookTransactionUpdateInput!, where: BookTransactionWhereInput): BatchPayload!
  updateManyTransactionSplits(data: TransactionSplitUpdateInput!, where: TransactionSplitWhereInput): BatchPayload!
  updateManyBooks(data: BookUpdateInput!, where: BookWhereInput): BatchPayload!
  updateManyCourses(data: CourseUpdateInput!, where: CourseWhereInput): BatchPayload!
  updateManyMovieTransactions(data: MovieTransactionUpdateInput!, where: MovieTransactionWhereInput): BatchPayload!
  updateManyTvShows(data: TvShowUpdateInput!, where: TvShowWhereInput): BatchPayload!
  updateManyFavorites(data: FavoriteUpdateInput!, where: FavoriteWhereInput): BatchPayload!
  updateManyEvents(data: EventUpdateInput!, where: EventWhereInput): BatchPayload!
  updateManyLocations(data: LocationUpdateInput!, where: LocationWhereInput): BatchPayload!
  updateManySchools(data: SchoolUpdateInput!, where: SchoolWhereInput): BatchPayload!
  updateManyAccounts(data: AccountUpdateInput!, where: AccountWhereInput): BatchPayload!
  updateManyFixedCosts(data: FixedCostUpdateInput!, where: FixedCostWhereInput): BatchPayload!
  updateManyGoodOrServices(data: GoodOrServiceUpdateInput!, where: GoodOrServiceWhereInput): BatchPayload!
  updateManyHumans(data: HumanUpdateInput!, where: HumanWhereInput): BatchPayload!
  deleteManyCourseLectures(where: CourseLectureWhereInput): BatchPayload!
  deleteManyCourseAssignments(where: CourseAssignmentWhereInput): BatchPayload!
  deleteManyTvEpisodeTransactions(where: TvEpisodeTransactionWhereInput): BatchPayload!
  deleteManyTimelines(where: TimelineWhereInput): BatchPayload!
  deleteManyOverviews(where: OverviewWhereInput): BatchPayload!
  deleteManyWishLists(where: WishListWhereInput): BatchPayload!
  deleteManyContactInfoes(where: ContactInfoWhereInput): BatchPayload!
  deleteManyWeightHistoryItems(where: WeightHistoryItemWhereInput): BatchPayload!
  deleteManyTvEpisodes(where: TvEpisodeWhereInput): BatchPayload!
  deleteManyBudgets(where: BudgetWhereInput): BatchPayload!
  deleteManyFinanceGoalses(where: FinanceGoalsWhereInput): BatchPayload!
  deleteManyTasks(where: TaskWhereInput): BatchPayload!
  deleteManyMovies(where: MovieWhereInput): BatchPayload!
  deleteManyTransactions(where: TransactionWhereInput): BatchPayload!
  deleteManyEducations(where: EducationWhereInput): BatchPayload!
  deleteManyBookTransactions(where: BookTransactionWhereInput): BatchPayload!
  deleteManyTransactionSplits(where: TransactionSplitWhereInput): BatchPayload!
  deleteManyBooks(where: BookWhereInput): BatchPayload!
  deleteManyCourses(where: CourseWhereInput): BatchPayload!
  deleteManyMovieTransactions(where: MovieTransactionWhereInput): BatchPayload!
  deleteManyTvShows(where: TvShowWhereInput): BatchPayload!
  deleteManyFavorites(where: FavoriteWhereInput): BatchPayload!
  deleteManyEvents(where: EventWhereInput): BatchPayload!
  deleteManyLocations(where: LocationWhereInput): BatchPayload!
  deleteManySchools(where: SchoolWhereInput): BatchPayload!
  deleteManyAccounts(where: AccountWhereInput): BatchPayload!
  deleteManyFixedCosts(where: FixedCostWhereInput): BatchPayload!
  deleteManyGoodOrServices(where: GoodOrServiceWhereInput): BatchPayload!
  deleteManyHumans(where: HumanWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

"""An object with an ID"""
interface Node {
  """The id of the object."""
  id: ID!
}

type Overview implements Node {
  id: ID!
  net_worth: Float!
  credit_score: Int
  income: Float!
  goals(where: FinanceGoalsWhereInput, orderBy: FinanceGoalsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [FinanceGoals!]
  budget(where: BudgetWhereInput): Budget
  accounts(where: AccountWhereInput, orderBy: AccountOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Account!]
}

"""A connection to a list of items."""
type OverviewConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [OverviewEdge]!
  aggregate: AggregateOverview!
}

input OverviewCreateInput {
  net_worth: Float!
  credit_score: Int
  income: Float!
  goals: FinanceGoalsCreateManyInput
  budget: BudgetCreateOneInput
  accounts: AccountCreateManyInput
}

"""An edge in a connection."""
type OverviewEdge {
  """The item at the end of the edge."""
  node: Overview!

  """A cursor for use in pagination."""
  cursor: String!
}

enum OverviewOrderByInput {
  id_ASC
  id_DESC
  net_worth_ASC
  net_worth_DESC
  credit_score_ASC
  credit_score_DESC
  income_ASC
  income_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type OverviewPreviousValues {
  id: ID!
  net_worth: Float!
  credit_score: Int
  income: Float!
}

type OverviewSubscriptionPayload {
  mutation: MutationType!
  node: Overview
  updatedFields: [String!]
  previousValues: OverviewPreviousValues
}

input OverviewSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [OverviewSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [OverviewSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [OverviewSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: OverviewWhereInput
}

input OverviewUpdateInput {
  net_worth: Float
  credit_score: Int
  income: Float
  goals: FinanceGoalsUpdateManyInput
  budget: BudgetUpdateOneInput
  accounts: AccountUpdateManyInput
}

input OverviewWhereInput {
  """Logical AND on all given filters."""
  AND: [OverviewWhereInput!]

  """Logical OR on all given filters."""
  OR: [OverviewWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [OverviewWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  net_worth: Float

  """All values that are not equal to given value."""
  net_worth_not: Float

  """All values that are contained in given list."""
  net_worth_in: [Float!]

  """All values that are not contained in given list."""
  net_worth_not_in: [Float!]

  """All values less than the given value."""
  net_worth_lt: Float

  """All values less than or equal the given value."""
  net_worth_lte: Float

  """All values greater than the given value."""
  net_worth_gt: Float

  """All values greater than or equal the given value."""
  net_worth_gte: Float
  credit_score: Int

  """All values that are not equal to given value."""
  credit_score_not: Int

  """All values that are contained in given list."""
  credit_score_in: [Int!]

  """All values that are not contained in given list."""
  credit_score_not_in: [Int!]

  """All values less than the given value."""
  credit_score_lt: Int

  """All values less than or equal the given value."""
  credit_score_lte: Int

  """All values greater than the given value."""
  credit_score_gt: Int

  """All values greater than or equal the given value."""
  credit_score_gte: Int
  income: Float

  """All values that are not equal to given value."""
  income_not: Float

  """All values that are contained in given list."""
  income_in: [Float!]

  """All values that are not contained in given list."""
  income_not_in: [Float!]

  """All values less than the given value."""
  income_lt: Float

  """All values less than or equal the given value."""
  income_lte: Float

  """All values greater than the given value."""
  income_gt: Float

  """All values greater than or equal the given value."""
  income_gte: Float
  goals_every: FinanceGoalsWhereInput
  goals_some: FinanceGoalsWhereInput
  goals_none: FinanceGoalsWhereInput
  budget: BudgetWhereInput
  accounts_every: AccountWhereInput
  accounts_some: AccountWhereInput
  accounts_none: AccountWhereInput
}

input OverviewWhereUniqueInput {
  id: ID
}

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String

  """When paginating forwards, the cursor to continue."""
  endCursor: String
}

type Query {
  courseLectures(where: CourseLectureWhereInput, orderBy: CourseLectureOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CourseLecture]!
  courseAssignments(where: CourseAssignmentWhereInput, orderBy: CourseAssignmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CourseAssignment]!
  tvEpisodeTransactions(where: TvEpisodeTransactionWhereInput, orderBy: TvEpisodeTransactionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [TvEpisodeTransaction]!
  timelines(where: TimelineWhereInput, orderBy: TimelineOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Timeline]!
  overviews(where: OverviewWhereInput, orderBy: OverviewOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Overview]!
  wishLists(where: WishListWhereInput, orderBy: WishListOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [WishList]!
  contactInfoes(where: ContactInfoWhereInput, orderBy: ContactInfoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ContactInfo]!
  weightHistoryItems(where: WeightHistoryItemWhereInput, orderBy: WeightHistoryItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [WeightHistoryItem]!
  tvEpisodes(where: TvEpisodeWhereInput, orderBy: TvEpisodeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [TvEpisode]!
  budgets(where: BudgetWhereInput, orderBy: BudgetOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Budget]!
  financeGoalses(where: FinanceGoalsWhereInput, orderBy: FinanceGoalsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [FinanceGoals]!
  tasks(where: TaskWhereInput, orderBy: TaskOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Task]!
  movies(where: MovieWhereInput, orderBy: MovieOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Movie]!
  transactions(where: TransactionWhereInput, orderBy: TransactionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Transaction]!
  educations(where: EducationWhereInput, orderBy: EducationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Education]!
  bookTransactions(where: BookTransactionWhereInput, orderBy: BookTransactionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BookTransaction]!
  transactionSplits(where: TransactionSplitWhereInput, orderBy: TransactionSplitOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [TransactionSplit]!
  books(where: BookWhereInput, orderBy: BookOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Book]!
  courses(where: CourseWhereInput, orderBy: CourseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Course]!
  movieTransactions(where: MovieTransactionWhereInput, orderBy: MovieTransactionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MovieTransaction]!
  tvShows(where: TvShowWhereInput, orderBy: TvShowOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [TvShow]!
  favorites(where: FavoriteWhereInput, orderBy: FavoriteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Favorite]!
  events(where: EventWhereInput, orderBy: EventOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Event]!
  locations(where: LocationWhereInput, orderBy: LocationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Location]!
  schools(where: SchoolWhereInput, orderBy: SchoolOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [School]!
  accounts(where: AccountWhereInput, orderBy: AccountOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Account]!
  fixedCosts(where: FixedCostWhereInput, orderBy: FixedCostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [FixedCost]!
  goodOrServices(where: GoodOrServiceWhereInput, orderBy: GoodOrServiceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [GoodOrService]!
  humans(where: HumanWhereInput, orderBy: HumanOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Human]!
  courseLecture(where: CourseLectureWhereUniqueInput!): CourseLecture
  courseAssignment(where: CourseAssignmentWhereUniqueInput!): CourseAssignment
  tvEpisodeTransaction(where: TvEpisodeTransactionWhereUniqueInput!): TvEpisodeTransaction
  timeline(where: TimelineWhereUniqueInput!): Timeline
  overview(where: OverviewWhereUniqueInput!): Overview
  weightHistoryItem(where: WeightHistoryItemWhereUniqueInput!): WeightHistoryItem
  tvEpisode(where: TvEpisodeWhereUniqueInput!): TvEpisode
  budget(where: BudgetWhereUniqueInput!): Budget
  financeGoals(where: FinanceGoalsWhereUniqueInput!): FinanceGoals
  task(where: TaskWhereUniqueInput!): Task
  movie(where: MovieWhereUniqueInput!): Movie
  transaction(where: TransactionWhereUniqueInput!): Transaction
  education(where: EducationWhereUniqueInput!): Education
  bookTransaction(where: BookTransactionWhereUniqueInput!): BookTransaction
  book(where: BookWhereUniqueInput!): Book
  movieTransaction(where: MovieTransactionWhereUniqueInput!): MovieTransaction
  tvShow(where: TvShowWhereUniqueInput!): TvShow
  favorite(where: FavoriteWhereUniqueInput!): Favorite
  event(where: EventWhereUniqueInput!): Event
  location(where: LocationWhereUniqueInput!): Location
  school(where: SchoolWhereUniqueInput!): School
  account(where: AccountWhereUniqueInput!): Account
  fixedCost(where: FixedCostWhereUniqueInput!): FixedCost
  goodOrService(where: GoodOrServiceWhereUniqueInput!): GoodOrService
  human(where: HumanWhereUniqueInput!): Human
  courseLecturesConnection(where: CourseLectureWhereInput, orderBy: CourseLectureOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CourseLectureConnection!
  courseAssignmentsConnection(where: CourseAssignmentWhereInput, orderBy: CourseAssignmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CourseAssignmentConnection!
  tvEpisodeTransactionsConnection(where: TvEpisodeTransactionWhereInput, orderBy: TvEpisodeTransactionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TvEpisodeTransactionConnection!
  timelinesConnection(where: TimelineWhereInput, orderBy: TimelineOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TimelineConnection!
  overviewsConnection(where: OverviewWhereInput, orderBy: OverviewOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): OverviewConnection!
  wishListsConnection(where: WishListWhereInput, orderBy: WishListOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): WishListConnection!
  contactInfoesConnection(where: ContactInfoWhereInput, orderBy: ContactInfoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ContactInfoConnection!
  weightHistoryItemsConnection(where: WeightHistoryItemWhereInput, orderBy: WeightHistoryItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): WeightHistoryItemConnection!
  tvEpisodesConnection(where: TvEpisodeWhereInput, orderBy: TvEpisodeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TvEpisodeConnection!
  budgetsConnection(where: BudgetWhereInput, orderBy: BudgetOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BudgetConnection!
  financeGoalsesConnection(where: FinanceGoalsWhereInput, orderBy: FinanceGoalsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FinanceGoalsConnection!
  tasksConnection(where: TaskWhereInput, orderBy: TaskOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TaskConnection!
  moviesConnection(where: MovieWhereInput, orderBy: MovieOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MovieConnection!
  transactionsConnection(where: TransactionWhereInput, orderBy: TransactionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TransactionConnection!
  educationsConnection(where: EducationWhereInput, orderBy: EducationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): EducationConnection!
  bookTransactionsConnection(where: BookTransactionWhereInput, orderBy: BookTransactionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BookTransactionConnection!
  transactionSplitsConnection(where: TransactionSplitWhereInput, orderBy: TransactionSplitOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TransactionSplitConnection!
  booksConnection(where: BookWhereInput, orderBy: BookOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BookConnection!
  coursesConnection(where: CourseWhereInput, orderBy: CourseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CourseConnection!
  movieTransactionsConnection(where: MovieTransactionWhereInput, orderBy: MovieTransactionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MovieTransactionConnection!
  tvShowsConnection(where: TvShowWhereInput, orderBy: TvShowOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TvShowConnection!
  favoritesConnection(where: FavoriteWhereInput, orderBy: FavoriteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FavoriteConnection!
  eventsConnection(where: EventWhereInput, orderBy: EventOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): EventConnection!
  locationsConnection(where: LocationWhereInput, orderBy: LocationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LocationConnection!
  schoolsConnection(where: SchoolWhereInput, orderBy: SchoolOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SchoolConnection!
  accountsConnection(where: AccountWhereInput, orderBy: AccountOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AccountConnection!
  fixedCostsConnection(where: FixedCostWhereInput, orderBy: FixedCostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FixedCostConnection!
  goodOrServicesConnection(where: GoodOrServiceWhereInput, orderBy: GoodOrServiceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GoodOrServiceConnection!
  humansConnection(where: HumanWhereInput, orderBy: HumanOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): HumanConnection!

  """Fetches an object given its ID"""
  node(
    """The ID of an object"""
    id: ID!
  ): Node
}

type School implements Node {
  id: ID!
  name: String!
  location: String!
}

"""A connection to a list of items."""
type SchoolConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [SchoolEdge]!
  aggregate: AggregateSchool!
}

input SchoolCreateInput {
  name: String!
  location: String!
}

input SchoolCreateManyInput {
  create: [SchoolCreateInput!]
  connect: [SchoolWhereUniqueInput!]
}

input SchoolCreateOneInput {
  create: SchoolCreateInput
  connect: SchoolWhereUniqueInput
}

"""An edge in a connection."""
type SchoolEdge {
  """The item at the end of the edge."""
  node: School!

  """A cursor for use in pagination."""
  cursor: String!
}

enum SchoolOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  location_ASC
  location_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type SchoolPreviousValues {
  id: ID!
  name: String!
  location: String!
}

type SchoolSubscriptionPayload {
  mutation: MutationType!
  node: School
  updatedFields: [String!]
  previousValues: SchoolPreviousValues
}

input SchoolSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [SchoolSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [SchoolSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [SchoolSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: SchoolWhereInput
}

input SchoolUpdateDataInput {
  name: String
  location: String
}

input SchoolUpdateInput {
  name: String
  location: String
}

input SchoolUpdateManyInput {
  create: [SchoolCreateInput!]
  connect: [SchoolWhereUniqueInput!]
  disconnect: [SchoolWhereUniqueInput!]
  delete: [SchoolWhereUniqueInput!]
  update: [SchoolUpdateWithWhereUniqueNestedInput!]
  upsert: [SchoolUpsertWithWhereUniqueNestedInput!]
}

input SchoolUpdateOneInput {
  create: SchoolCreateInput
  connect: SchoolWhereUniqueInput
  delete: Boolean
  update: SchoolUpdateDataInput
  upsert: SchoolUpsertNestedInput
}

input SchoolUpdateWithWhereUniqueNestedInput {
  where: SchoolWhereUniqueInput!
  data: SchoolUpdateDataInput!
}

input SchoolUpsertNestedInput {
  update: SchoolUpdateDataInput!
  create: SchoolCreateInput!
}

input SchoolUpsertWithWhereUniqueNestedInput {
  where: SchoolWhereUniqueInput!
  update: SchoolUpdateDataInput!
  create: SchoolCreateInput!
}

input SchoolWhereInput {
  """Logical AND on all given filters."""
  AND: [SchoolWhereInput!]

  """Logical OR on all given filters."""
  OR: [SchoolWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [SchoolWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  name: String

  """All values that are not equal to given value."""
  name_not: String

  """All values that are contained in given list."""
  name_in: [String!]

  """All values that are not contained in given list."""
  name_not_in: [String!]

  """All values less than the given value."""
  name_lt: String

  """All values less than or equal the given value."""
  name_lte: String

  """All values greater than the given value."""
  name_gt: String

  """All values greater than or equal the given value."""
  name_gte: String

  """All values containing the given string."""
  name_contains: String

  """All values not containing the given string."""
  name_not_contains: String

  """All values starting with the given string."""
  name_starts_with: String

  """All values not starting with the given string."""
  name_not_starts_with: String

  """All values ending with the given string."""
  name_ends_with: String

  """All values not ending with the given string."""
  name_not_ends_with: String
  location: String

  """All values that are not equal to given value."""
  location_not: String

  """All values that are contained in given list."""
  location_in: [String!]

  """All values that are not contained in given list."""
  location_not_in: [String!]

  """All values less than the given value."""
  location_lt: String

  """All values less than or equal the given value."""
  location_lte: String

  """All values greater than the given value."""
  location_gt: String

  """All values greater than or equal the given value."""
  location_gte: String

  """All values containing the given string."""
  location_contains: String

  """All values not containing the given string."""
  location_not_contains: String

  """All values starting with the given string."""
  location_starts_with: String

  """All values not starting with the given string."""
  location_not_starts_with: String

  """All values ending with the given string."""
  location_ends_with: String

  """All values not ending with the given string."""
  location_not_ends_with: String
}

input SchoolWhereUniqueInput {
  id: ID
}

type Subscription {
  courseLecture(where: CourseLectureSubscriptionWhereInput): CourseLectureSubscriptionPayload
  courseAssignment(where: CourseAssignmentSubscriptionWhereInput): CourseAssignmentSubscriptionPayload
  tvEpisodeTransaction(where: TvEpisodeTransactionSubscriptionWhereInput): TvEpisodeTransactionSubscriptionPayload
  timeline(where: TimelineSubscriptionWhereInput): TimelineSubscriptionPayload
  overview(where: OverviewSubscriptionWhereInput): OverviewSubscriptionPayload
  wishList(where: WishListSubscriptionWhereInput): WishListSubscriptionPayload
  contactInfo(where: ContactInfoSubscriptionWhereInput): ContactInfoSubscriptionPayload
  weightHistoryItem(where: WeightHistoryItemSubscriptionWhereInput): WeightHistoryItemSubscriptionPayload
  tvEpisode(where: TvEpisodeSubscriptionWhereInput): TvEpisodeSubscriptionPayload
  budget(where: BudgetSubscriptionWhereInput): BudgetSubscriptionPayload
  financeGoals(where: FinanceGoalsSubscriptionWhereInput): FinanceGoalsSubscriptionPayload
  task(where: TaskSubscriptionWhereInput): TaskSubscriptionPayload
  movie(where: MovieSubscriptionWhereInput): MovieSubscriptionPayload
  transaction(where: TransactionSubscriptionWhereInput): TransactionSubscriptionPayload
  education(where: EducationSubscriptionWhereInput): EducationSubscriptionPayload
  bookTransaction(where: BookTransactionSubscriptionWhereInput): BookTransactionSubscriptionPayload
  transactionSplit(where: TransactionSplitSubscriptionWhereInput): TransactionSplitSubscriptionPayload
  book(where: BookSubscriptionWhereInput): BookSubscriptionPayload
  course(where: CourseSubscriptionWhereInput): CourseSubscriptionPayload
  movieTransaction(where: MovieTransactionSubscriptionWhereInput): MovieTransactionSubscriptionPayload
  tvShow(where: TvShowSubscriptionWhereInput): TvShowSubscriptionPayload
  favorite(where: FavoriteSubscriptionWhereInput): FavoriteSubscriptionPayload
  event(where: EventSubscriptionWhereInput): EventSubscriptionPayload
  location(where: LocationSubscriptionWhereInput): LocationSubscriptionPayload
  school(where: SchoolSubscriptionWhereInput): SchoolSubscriptionPayload
  account(where: AccountSubscriptionWhereInput): AccountSubscriptionPayload
  fixedCost(where: FixedCostSubscriptionWhereInput): FixedCostSubscriptionPayload
  goodOrService(where: GoodOrServiceSubscriptionWhereInput): GoodOrServiceSubscriptionPayload
  human(where: HumanSubscriptionWhereInput): HumanSubscriptionPayload
}

type Task implements Node {
  id: ID!
  name: String
  start: DateTime!
  end: DateTime!
  status: TaskStatus
}

"""A connection to a list of items."""
type TaskConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [TaskEdge]!
  aggregate: AggregateTask!
}

input TaskCreateInput {
  name: String
  start: DateTime!
  end: DateTime!
  status: TaskStatus
}

input TaskCreateManyInput {
  create: [TaskCreateInput!]
  connect: [TaskWhereUniqueInput!]
}

"""An edge in a connection."""
type TaskEdge {
  """The item at the end of the edge."""
  node: Task!

  """A cursor for use in pagination."""
  cursor: String!
}

enum TaskOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  start_ASC
  start_DESC
  end_ASC
  end_DESC
  status_ASC
  status_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type TaskPreviousValues {
  id: ID!
  name: String
  start: DateTime!
  end: DateTime!
  status: TaskStatus
}

enum TaskStatus {
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

type TaskSubscriptionPayload {
  mutation: MutationType!
  node: Task
  updatedFields: [String!]
  previousValues: TaskPreviousValues
}

input TaskSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [TaskSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [TaskSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [TaskSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: TaskWhereInput
}

input TaskUpdateDataInput {
  name: String
  start: DateTime
  end: DateTime
  status: TaskStatus
}

input TaskUpdateInput {
  name: String
  start: DateTime
  end: DateTime
  status: TaskStatus
}

input TaskUpdateManyInput {
  create: [TaskCreateInput!]
  connect: [TaskWhereUniqueInput!]
  disconnect: [TaskWhereUniqueInput!]
  delete: [TaskWhereUniqueInput!]
  update: [TaskUpdateWithWhereUniqueNestedInput!]
  upsert: [TaskUpsertWithWhereUniqueNestedInput!]
}

input TaskUpdateWithWhereUniqueNestedInput {
  where: TaskWhereUniqueInput!
  data: TaskUpdateDataInput!
}

input TaskUpsertWithWhereUniqueNestedInput {
  where: TaskWhereUniqueInput!
  update: TaskUpdateDataInput!
  create: TaskCreateInput!
}

input TaskWhereInput {
  """Logical AND on all given filters."""
  AND: [TaskWhereInput!]

  """Logical OR on all given filters."""
  OR: [TaskWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [TaskWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  name: String

  """All values that are not equal to given value."""
  name_not: String

  """All values that are contained in given list."""
  name_in: [String!]

  """All values that are not contained in given list."""
  name_not_in: [String!]

  """All values less than the given value."""
  name_lt: String

  """All values less than or equal the given value."""
  name_lte: String

  """All values greater than the given value."""
  name_gt: String

  """All values greater than or equal the given value."""
  name_gte: String

  """All values containing the given string."""
  name_contains: String

  """All values not containing the given string."""
  name_not_contains: String

  """All values starting with the given string."""
  name_starts_with: String

  """All values not starting with the given string."""
  name_not_starts_with: String

  """All values ending with the given string."""
  name_ends_with: String

  """All values not ending with the given string."""
  name_not_ends_with: String
  start: DateTime

  """All values that are not equal to given value."""
  start_not: DateTime

  """All values that are contained in given list."""
  start_in: [DateTime!]

  """All values that are not contained in given list."""
  start_not_in: [DateTime!]

  """All values less than the given value."""
  start_lt: DateTime

  """All values less than or equal the given value."""
  start_lte: DateTime

  """All values greater than the given value."""
  start_gt: DateTime

  """All values greater than or equal the given value."""
  start_gte: DateTime
  end: DateTime

  """All values that are not equal to given value."""
  end_not: DateTime

  """All values that are contained in given list."""
  end_in: [DateTime!]

  """All values that are not contained in given list."""
  end_not_in: [DateTime!]

  """All values less than the given value."""
  end_lt: DateTime

  """All values less than or equal the given value."""
  end_lte: DateTime

  """All values greater than the given value."""
  end_gt: DateTime

  """All values greater than or equal the given value."""
  end_gte: DateTime
  status: TaskStatus

  """All values that are not equal to given value."""
  status_not: TaskStatus

  """All values that are contained in given list."""
  status_in: [TaskStatus!]

  """All values that are not contained in given list."""
  status_not_in: [TaskStatus!]
}

input TaskWhereUniqueInput {
  id: ID
}

type Timeline implements Node {
  id: ID!
  events(where: EventWhereInput, orderBy: EventOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Event!]
  belongs_to(where: HumanWhereInput): Human!
}

"""A connection to a list of items."""
type TimelineConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [TimelineEdge]!
  aggregate: AggregateTimeline!
}

input TimelineCreateInput {
  events: EventCreateManyInput
  belongs_to: HumanCreateOneInput!
}

"""An edge in a connection."""
type TimelineEdge {
  """The item at the end of the edge."""
  node: Timeline!

  """A cursor for use in pagination."""
  cursor: String!
}

enum TimelineOrderByInput {
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type TimelinePreviousValues {
  id: ID!
}

type TimelineSubscriptionPayload {
  mutation: MutationType!
  node: Timeline
  updatedFields: [String!]
  previousValues: TimelinePreviousValues
}

input TimelineSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [TimelineSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [TimelineSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [TimelineSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: TimelineWhereInput
}

input TimelineUpdateInput {
  events: EventUpdateManyInput
  belongs_to: HumanUpdateOneInput
}

input TimelineWhereInput {
  """Logical AND on all given filters."""
  AND: [TimelineWhereInput!]

  """Logical OR on all given filters."""
  OR: [TimelineWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [TimelineWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  events_every: EventWhereInput
  events_some: EventWhereInput
  events_none: EventWhereInput
  belongs_to: HumanWhereInput
}

input TimelineWhereUniqueInput {
  id: ID
}

type Transaction implements Node {
  id: ID!
  payee: String!
  amount: Float!
  date: String!
  category: String!
  splits(where: TransactionSplitWhereInput, orderBy: TransactionSplitOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [TransactionSplit!]
  location(where: LocationWhereInput): Location
  items(where: GoodOrServiceWhereInput, orderBy: GoodOrServiceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [GoodOrService!]
  with(where: HumanWhereInput, orderBy: HumanOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Human!]
  event(where: EventWhereInput): Event
}

"""A connection to a list of items."""
type TransactionConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [TransactionEdge]!
  aggregate: AggregateTransaction!
}

input TransactionCreateInput {
  payee: String!
  amount: Float!
  date: String!
  category: String!
  splits: TransactionSplitCreateManyInput
  location: LocationCreateOneInput
  items: GoodOrServiceCreateManyWithoutTransactionInput
  with: HumanCreateManyInput
  event: EventCreateOneInput
}

input TransactionCreateManyInput {
  create: [TransactionCreateInput!]
  connect: [TransactionWhereUniqueInput!]
}

input TransactionCreateOneWithoutItemsInput {
  create: TransactionCreateWithoutItemsInput
  connect: TransactionWhereUniqueInput
}

input TransactionCreateWithoutItemsInput {
  payee: String!
  amount: Float!
  date: String!
  category: String!
  splits: TransactionSplitCreateManyInput
  location: LocationCreateOneInput
  with: HumanCreateManyInput
  event: EventCreateOneInput
}

"""An edge in a connection."""
type TransactionEdge {
  """The item at the end of the edge."""
  node: Transaction!

  """A cursor for use in pagination."""
  cursor: String!
}

enum TransactionOrderByInput {
  id_ASC
  id_DESC
  payee_ASC
  payee_DESC
  amount_ASC
  amount_DESC
  date_ASC
  date_DESC
  category_ASC
  category_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type TransactionPreviousValues {
  id: ID!
  payee: String!
  amount: Float!
  date: String!
  category: String!
}

type TransactionSplit {
  human(where: HumanWhereInput): Human!
  percentage: Float
  amount: Float
  pending: Boolean
}

"""A connection to a list of items."""
type TransactionSplitConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [TransactionSplitEdge]!
  aggregate: AggregateTransactionSplit!
}

input TransactionSplitCreateInput {
  percentage: Float
  amount: Float
  pending: Boolean
  human: HumanCreateOneInput!
}

input TransactionSplitCreateManyInput {
  create: [TransactionSplitCreateInput!]
}

"""An edge in a connection."""
type TransactionSplitEdge {
  """The item at the end of the edge."""
  node: TransactionSplit!

  """A cursor for use in pagination."""
  cursor: String!
}

enum TransactionSplitOrderByInput {
  percentage_ASC
  percentage_DESC
  amount_ASC
  amount_DESC
  pending_ASC
  pending_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type TransactionSplitPreviousValues {
  percentage: Float
  amount: Float
  pending: Boolean
}

type TransactionSplitSubscriptionPayload {
  mutation: MutationType!
  node: TransactionSplit
  updatedFields: [String!]
  previousValues: TransactionSplitPreviousValues
}

input TransactionSplitSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [TransactionSplitSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [TransactionSplitSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [TransactionSplitSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: TransactionSplitWhereInput
}

input TransactionSplitUpdateInput {
  percentage: Float
  amount: Float
  pending: Boolean
  human: HumanUpdateOneInput
}

input TransactionSplitUpdateManyInput {
  create: [TransactionSplitCreateInput!]
}

input TransactionSplitWhereInput {
  """Logical AND on all given filters."""
  AND: [TransactionSplitWhereInput!]

  """Logical OR on all given filters."""
  OR: [TransactionSplitWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [TransactionSplitWhereInput!]
  percentage: Float

  """All values that are not equal to given value."""
  percentage_not: Float

  """All values that are contained in given list."""
  percentage_in: [Float!]

  """All values that are not contained in given list."""
  percentage_not_in: [Float!]

  """All values less than the given value."""
  percentage_lt: Float

  """All values less than or equal the given value."""
  percentage_lte: Float

  """All values greater than the given value."""
  percentage_gt: Float

  """All values greater than or equal the given value."""
  percentage_gte: Float
  amount: Float

  """All values that are not equal to given value."""
  amount_not: Float

  """All values that are contained in given list."""
  amount_in: [Float!]

  """All values that are not contained in given list."""
  amount_not_in: [Float!]

  """All values less than the given value."""
  amount_lt: Float

  """All values less than or equal the given value."""
  amount_lte: Float

  """All values greater than the given value."""
  amount_gt: Float

  """All values greater than or equal the given value."""
  amount_gte: Float
  pending: Boolean

  """All values that are not equal to given value."""
  pending_not: Boolean
  human: HumanWhereInput
}

type TransactionSubscriptionPayload {
  mutation: MutationType!
  node: Transaction
  updatedFields: [String!]
  previousValues: TransactionPreviousValues
}

input TransactionSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [TransactionSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [TransactionSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [TransactionSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: TransactionWhereInput
}

input TransactionUpdateDataInput {
  payee: String
  amount: Float
  date: String
  category: String
  splits: TransactionSplitUpdateManyInput
  location: LocationUpdateOneInput
  items: GoodOrServiceUpdateManyWithoutTransactionInput
  with: HumanUpdateManyInput
  event: EventUpdateOneInput
}

input TransactionUpdateInput {
  payee: String
  amount: Float
  date: String
  category: String
  splits: TransactionSplitUpdateManyInput
  location: LocationUpdateOneInput
  items: GoodOrServiceUpdateManyWithoutTransactionInput
  with: HumanUpdateManyInput
  event: EventUpdateOneInput
}

input TransactionUpdateManyInput {
  create: [TransactionCreateInput!]
  connect: [TransactionWhereUniqueInput!]
  disconnect: [TransactionWhereUniqueInput!]
  delete: [TransactionWhereUniqueInput!]
  update: [TransactionUpdateWithWhereUniqueNestedInput!]
  upsert: [TransactionUpsertWithWhereUniqueNestedInput!]
}

input TransactionUpdateOneWithoutItemsInput {
  create: TransactionCreateWithoutItemsInput
  connect: TransactionWhereUniqueInput
  disconnect: Boolean
  delete: Boolean
  update: TransactionUpdateWithoutItemsDataInput
  upsert: TransactionUpsertWithoutItemsInput
}

input TransactionUpdateWithoutItemsDataInput {
  payee: String
  amount: Float
  date: String
  category: String
  splits: TransactionSplitUpdateManyInput
  location: LocationUpdateOneInput
  with: HumanUpdateManyInput
  event: EventUpdateOneInput
}

input TransactionUpdateWithWhereUniqueNestedInput {
  where: TransactionWhereUniqueInput!
  data: TransactionUpdateDataInput!
}

input TransactionUpsertWithoutItemsInput {
  update: TransactionUpdateWithoutItemsDataInput!
  create: TransactionCreateWithoutItemsInput!
}

input TransactionUpsertWithWhereUniqueNestedInput {
  where: TransactionWhereUniqueInput!
  update: TransactionUpdateDataInput!
  create: TransactionCreateInput!
}

input TransactionWhereInput {
  """Logical AND on all given filters."""
  AND: [TransactionWhereInput!]

  """Logical OR on all given filters."""
  OR: [TransactionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [TransactionWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  payee: String

  """All values that are not equal to given value."""
  payee_not: String

  """All values that are contained in given list."""
  payee_in: [String!]

  """All values that are not contained in given list."""
  payee_not_in: [String!]

  """All values less than the given value."""
  payee_lt: String

  """All values less than or equal the given value."""
  payee_lte: String

  """All values greater than the given value."""
  payee_gt: String

  """All values greater than or equal the given value."""
  payee_gte: String

  """All values containing the given string."""
  payee_contains: String

  """All values not containing the given string."""
  payee_not_contains: String

  """All values starting with the given string."""
  payee_starts_with: String

  """All values not starting with the given string."""
  payee_not_starts_with: String

  """All values ending with the given string."""
  payee_ends_with: String

  """All values not ending with the given string."""
  payee_not_ends_with: String
  amount: Float

  """All values that are not equal to given value."""
  amount_not: Float

  """All values that are contained in given list."""
  amount_in: [Float!]

  """All values that are not contained in given list."""
  amount_not_in: [Float!]

  """All values less than the given value."""
  amount_lt: Float

  """All values less than or equal the given value."""
  amount_lte: Float

  """All values greater than the given value."""
  amount_gt: Float

  """All values greater than or equal the given value."""
  amount_gte: Float
  date: String

  """All values that are not equal to given value."""
  date_not: String

  """All values that are contained in given list."""
  date_in: [String!]

  """All values that are not contained in given list."""
  date_not_in: [String!]

  """All values less than the given value."""
  date_lt: String

  """All values less than or equal the given value."""
  date_lte: String

  """All values greater than the given value."""
  date_gt: String

  """All values greater than or equal the given value."""
  date_gte: String

  """All values containing the given string."""
  date_contains: String

  """All values not containing the given string."""
  date_not_contains: String

  """All values starting with the given string."""
  date_starts_with: String

  """All values not starting with the given string."""
  date_not_starts_with: String

  """All values ending with the given string."""
  date_ends_with: String

  """All values not ending with the given string."""
  date_not_ends_with: String
  category: String

  """All values that are not equal to given value."""
  category_not: String

  """All values that are contained in given list."""
  category_in: [String!]

  """All values that are not contained in given list."""
  category_not_in: [String!]

  """All values less than the given value."""
  category_lt: String

  """All values less than or equal the given value."""
  category_lte: String

  """All values greater than the given value."""
  category_gt: String

  """All values greater than or equal the given value."""
  category_gte: String

  """All values containing the given string."""
  category_contains: String

  """All values not containing the given string."""
  category_not_contains: String

  """All values starting with the given string."""
  category_starts_with: String

  """All values not starting with the given string."""
  category_not_starts_with: String

  """All values ending with the given string."""
  category_ends_with: String

  """All values not ending with the given string."""
  category_not_ends_with: String
  splits_every: TransactionSplitWhereInput
  splits_some: TransactionSplitWhereInput
  splits_none: TransactionSplitWhereInput
  location: LocationWhereInput
  items_every: GoodOrServiceWhereInput
  items_some: GoodOrServiceWhereInput
  items_none: GoodOrServiceWhereInput
  with_every: HumanWhereInput
  with_some: HumanWhereInput
  with_none: HumanWhereInput
  event: EventWhereInput
}

input TransactionWhereUniqueInput {
  id: ID
}

type TvEpisode implements Node {
  id: ID!
  name: String
  episode: Int
  season: Int
  watched: Boolean
  show(where: TvShowWhereInput): TvShow!
  date_watched: DateTime!
  release_date: DateTime!
}

"""A connection to a list of items."""
type TvEpisodeConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [TvEpisodeEdge]!
  aggregate: AggregateTvEpisode!
}

input TvEpisodeCreateInput {
  name: String
  episode: Int
  season: Int
  watched: Boolean
  date_watched: DateTime!
  release_date: DateTime!
  show: TvShowCreateOneWithoutEpisodesInput!
}

input TvEpisodeCreateManyWithoutShowInput {
  create: [TvEpisodeCreateWithoutShowInput!]
  connect: [TvEpisodeWhereUniqueInput!]
}

input TvEpisodeCreateOneInput {
  create: TvEpisodeCreateInput
  connect: TvEpisodeWhereUniqueInput
}

input TvEpisodeCreateWithoutShowInput {
  name: String
  episode: Int
  season: Int
  watched: Boolean
  date_watched: DateTime!
  release_date: DateTime!
}

"""An edge in a connection."""
type TvEpisodeEdge {
  """The item at the end of the edge."""
  node: TvEpisode!

  """A cursor for use in pagination."""
  cursor: String!
}

enum TvEpisodeOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  episode_ASC
  episode_DESC
  season_ASC
  season_DESC
  watched_ASC
  watched_DESC
  date_watched_ASC
  date_watched_DESC
  release_date_ASC
  release_date_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type TvEpisodePreviousValues {
  id: ID!
  name: String
  episode: Int
  season: Int
  watched: Boolean
  date_watched: DateTime!
  release_date: DateTime!
}

type TvEpisodeSubscriptionPayload {
  mutation: MutationType!
  node: TvEpisode
  updatedFields: [String!]
  previousValues: TvEpisodePreviousValues
}

input TvEpisodeSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [TvEpisodeSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [TvEpisodeSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [TvEpisodeSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: TvEpisodeWhereInput
}

type TvEpisodeTransaction implements Node {
  id: ID!
  human(where: HumanWhereInput): Human!
  show(where: TvShowWhereInput): TvShow!
  episode(where: TvEpisodeWhereInput): TvEpisode!
  date_watched: DateTime!
}

"""A connection to a list of items."""
type TvEpisodeTransactionConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [TvEpisodeTransactionEdge]!
  aggregate: AggregateTvEpisodeTransaction!
}

input TvEpisodeTransactionCreateInput {
  date_watched: DateTime!
  human: HumanCreateOneWithoutTv_showsInput!
  show: TvShowCreateOneInput!
  episode: TvEpisodeCreateOneInput!
}

input TvEpisodeTransactionCreateManyWithoutHumanInput {
  create: [TvEpisodeTransactionCreateWithoutHumanInput!]
  connect: [TvEpisodeTransactionWhereUniqueInput!]
}

input TvEpisodeTransactionCreateWithoutHumanInput {
  date_watched: DateTime!
  show: TvShowCreateOneInput!
  episode: TvEpisodeCreateOneInput!
}

"""An edge in a connection."""
type TvEpisodeTransactionEdge {
  """The item at the end of the edge."""
  node: TvEpisodeTransaction!

  """A cursor for use in pagination."""
  cursor: String!
}

enum TvEpisodeTransactionOrderByInput {
  id_ASC
  id_DESC
  date_watched_ASC
  date_watched_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type TvEpisodeTransactionPreviousValues {
  id: ID!
  date_watched: DateTime!
}

type TvEpisodeTransactionSubscriptionPayload {
  mutation: MutationType!
  node: TvEpisodeTransaction
  updatedFields: [String!]
  previousValues: TvEpisodeTransactionPreviousValues
}

input TvEpisodeTransactionSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [TvEpisodeTransactionSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [TvEpisodeTransactionSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [TvEpisodeTransactionSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: TvEpisodeTransactionWhereInput
}

input TvEpisodeTransactionUpdateInput {
  date_watched: DateTime
  human: HumanUpdateOneWithoutTv_showsInput
  show: TvShowUpdateOneInput
  episode: TvEpisodeUpdateOneInput
}

input TvEpisodeTransactionUpdateManyWithoutHumanInput {
  create: [TvEpisodeTransactionCreateWithoutHumanInput!]
  connect: [TvEpisodeTransactionWhereUniqueInput!]
  disconnect: [TvEpisodeTransactionWhereUniqueInput!]
  delete: [TvEpisodeTransactionWhereUniqueInput!]
  update: [TvEpisodeTransactionUpdateWithWhereUniqueWithoutHumanInput!]
  upsert: [TvEpisodeTransactionUpsertWithWhereUniqueWithoutHumanInput!]
}

input TvEpisodeTransactionUpdateWithoutHumanDataInput {
  date_watched: DateTime
  show: TvShowUpdateOneInput
  episode: TvEpisodeUpdateOneInput
}

input TvEpisodeTransactionUpdateWithWhereUniqueWithoutHumanInput {
  where: TvEpisodeTransactionWhereUniqueInput!
  data: TvEpisodeTransactionUpdateWithoutHumanDataInput!
}

input TvEpisodeTransactionUpsertWithWhereUniqueWithoutHumanInput {
  where: TvEpisodeTransactionWhereUniqueInput!
  update: TvEpisodeTransactionUpdateWithoutHumanDataInput!
  create: TvEpisodeTransactionCreateWithoutHumanInput!
}

input TvEpisodeTransactionWhereInput {
  """Logical AND on all given filters."""
  AND: [TvEpisodeTransactionWhereInput!]

  """Logical OR on all given filters."""
  OR: [TvEpisodeTransactionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [TvEpisodeTransactionWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  date_watched: DateTime

  """All values that are not equal to given value."""
  date_watched_not: DateTime

  """All values that are contained in given list."""
  date_watched_in: [DateTime!]

  """All values that are not contained in given list."""
  date_watched_not_in: [DateTime!]

  """All values less than the given value."""
  date_watched_lt: DateTime

  """All values less than or equal the given value."""
  date_watched_lte: DateTime

  """All values greater than the given value."""
  date_watched_gt: DateTime

  """All values greater than or equal the given value."""
  date_watched_gte: DateTime
  human: HumanWhereInput
  show: TvShowWhereInput
  episode: TvEpisodeWhereInput
}

input TvEpisodeTransactionWhereUniqueInput {
  id: ID
}

input TvEpisodeUpdateDataInput {
  name: String
  episode: Int
  season: Int
  watched: Boolean
  date_watched: DateTime
  release_date: DateTime
  show: TvShowUpdateOneWithoutEpisodesInput
}

input TvEpisodeUpdateInput {
  name: String
  episode: Int
  season: Int
  watched: Boolean
  date_watched: DateTime
  release_date: DateTime
  show: TvShowUpdateOneWithoutEpisodesInput
}

input TvEpisodeUpdateManyWithoutShowInput {
  create: [TvEpisodeCreateWithoutShowInput!]
  connect: [TvEpisodeWhereUniqueInput!]
  disconnect: [TvEpisodeWhereUniqueInput!]
  delete: [TvEpisodeWhereUniqueInput!]
  update: [TvEpisodeUpdateWithWhereUniqueWithoutShowInput!]
  upsert: [TvEpisodeUpsertWithWhereUniqueWithoutShowInput!]
}

input TvEpisodeUpdateOneInput {
  create: TvEpisodeCreateInput
  connect: TvEpisodeWhereUniqueInput
  delete: Boolean
  update: TvEpisodeUpdateDataInput
  upsert: TvEpisodeUpsertNestedInput
}

input TvEpisodeUpdateWithoutShowDataInput {
  name: String
  episode: Int
  season: Int
  watched: Boolean
  date_watched: DateTime
  release_date: DateTime
}

input TvEpisodeUpdateWithWhereUniqueWithoutShowInput {
  where: TvEpisodeWhereUniqueInput!
  data: TvEpisodeUpdateWithoutShowDataInput!
}

input TvEpisodeUpsertNestedInput {
  update: TvEpisodeUpdateDataInput!
  create: TvEpisodeCreateInput!
}

input TvEpisodeUpsertWithWhereUniqueWithoutShowInput {
  where: TvEpisodeWhereUniqueInput!
  update: TvEpisodeUpdateWithoutShowDataInput!
  create: TvEpisodeCreateWithoutShowInput!
}

input TvEpisodeWhereInput {
  """Logical AND on all given filters."""
  AND: [TvEpisodeWhereInput!]

  """Logical OR on all given filters."""
  OR: [TvEpisodeWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [TvEpisodeWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  name: String

  """All values that are not equal to given value."""
  name_not: String

  """All values that are contained in given list."""
  name_in: [String!]

  """All values that are not contained in given list."""
  name_not_in: [String!]

  """All values less than the given value."""
  name_lt: String

  """All values less than or equal the given value."""
  name_lte: String

  """All values greater than the given value."""
  name_gt: String

  """All values greater than or equal the given value."""
  name_gte: String

  """All values containing the given string."""
  name_contains: String

  """All values not containing the given string."""
  name_not_contains: String

  """All values starting with the given string."""
  name_starts_with: String

  """All values not starting with the given string."""
  name_not_starts_with: String

  """All values ending with the given string."""
  name_ends_with: String

  """All values not ending with the given string."""
  name_not_ends_with: String
  episode: Int

  """All values that are not equal to given value."""
  episode_not: Int

  """All values that are contained in given list."""
  episode_in: [Int!]

  """All values that are not contained in given list."""
  episode_not_in: [Int!]

  """All values less than the given value."""
  episode_lt: Int

  """All values less than or equal the given value."""
  episode_lte: Int

  """All values greater than the given value."""
  episode_gt: Int

  """All values greater than or equal the given value."""
  episode_gte: Int
  season: Int

  """All values that are not equal to given value."""
  season_not: Int

  """All values that are contained in given list."""
  season_in: [Int!]

  """All values that are not contained in given list."""
  season_not_in: [Int!]

  """All values less than the given value."""
  season_lt: Int

  """All values less than or equal the given value."""
  season_lte: Int

  """All values greater than the given value."""
  season_gt: Int

  """All values greater than or equal the given value."""
  season_gte: Int
  watched: Boolean

  """All values that are not equal to given value."""
  watched_not: Boolean
  date_watched: DateTime

  """All values that are not equal to given value."""
  date_watched_not: DateTime

  """All values that are contained in given list."""
  date_watched_in: [DateTime!]

  """All values that are not contained in given list."""
  date_watched_not_in: [DateTime!]

  """All values less than the given value."""
  date_watched_lt: DateTime

  """All values less than or equal the given value."""
  date_watched_lte: DateTime

  """All values greater than the given value."""
  date_watched_gt: DateTime

  """All values greater than or equal the given value."""
  date_watched_gte: DateTime
  release_date: DateTime

  """All values that are not equal to given value."""
  release_date_not: DateTime

  """All values that are contained in given list."""
  release_date_in: [DateTime!]

  """All values that are not contained in given list."""
  release_date_not_in: [DateTime!]

  """All values less than the given value."""
  release_date_lt: DateTime

  """All values less than or equal the given value."""
  release_date_lte: DateTime

  """All values greater than the given value."""
  release_date_gt: DateTime

  """All values greater than or equal the given value."""
  release_date_gte: DateTime
  show: TvShowWhereInput
}

input TvEpisodeWhereUniqueInput {
  id: ID
}

type TvShow implements Node {
  id: ID!
  name: String!
  episodes(where: TvEpisodeWhereInput, orderBy: TvEpisodeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [TvEpisode!]
}

"""A connection to a list of items."""
type TvShowConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [TvShowEdge]!
  aggregate: AggregateTvShow!
}

input TvShowCreateInput {
  name: String!
  episodes: TvEpisodeCreateManyWithoutShowInput
}

input TvShowCreateOneInput {
  create: TvShowCreateInput
  connect: TvShowWhereUniqueInput
}

input TvShowCreateOneWithoutEpisodesInput {
  create: TvShowCreateWithoutEpisodesInput
  connect: TvShowWhereUniqueInput
}

input TvShowCreateWithoutEpisodesInput {
  name: String!
}

"""An edge in a connection."""
type TvShowEdge {
  """The item at the end of the edge."""
  node: TvShow!

  """A cursor for use in pagination."""
  cursor: String!
}

enum TvShowOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type TvShowPreviousValues {
  id: ID!
  name: String!
}

type TvShowSubscriptionPayload {
  mutation: MutationType!
  node: TvShow
  updatedFields: [String!]
  previousValues: TvShowPreviousValues
}

input TvShowSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [TvShowSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [TvShowSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [TvShowSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: TvShowWhereInput
}

input TvShowUpdateDataInput {
  name: String
  episodes: TvEpisodeUpdateManyWithoutShowInput
}

input TvShowUpdateInput {
  name: String
  episodes: TvEpisodeUpdateManyWithoutShowInput
}

input TvShowUpdateOneInput {
  create: TvShowCreateInput
  connect: TvShowWhereUniqueInput
  delete: Boolean
  update: TvShowUpdateDataInput
  upsert: TvShowUpsertNestedInput
}

input TvShowUpdateOneWithoutEpisodesInput {
  create: TvShowCreateWithoutEpisodesInput
  connect: TvShowWhereUniqueInput
  delete: Boolean
  update: TvShowUpdateWithoutEpisodesDataInput
  upsert: TvShowUpsertWithoutEpisodesInput
}

input TvShowUpdateWithoutEpisodesDataInput {
  name: String
}

input TvShowUpsertNestedInput {
  update: TvShowUpdateDataInput!
  create: TvShowCreateInput!
}

input TvShowUpsertWithoutEpisodesInput {
  update: TvShowUpdateWithoutEpisodesDataInput!
  create: TvShowCreateWithoutEpisodesInput!
}

input TvShowWhereInput {
  """Logical AND on all given filters."""
  AND: [TvShowWhereInput!]

  """Logical OR on all given filters."""
  OR: [TvShowWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [TvShowWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  name: String

  """All values that are not equal to given value."""
  name_not: String

  """All values that are contained in given list."""
  name_in: [String!]

  """All values that are not contained in given list."""
  name_not_in: [String!]

  """All values less than the given value."""
  name_lt: String

  """All values less than or equal the given value."""
  name_lte: String

  """All values greater than the given value."""
  name_gt: String

  """All values greater than or equal the given value."""
  name_gte: String

  """All values containing the given string."""
  name_contains: String

  """All values not containing the given string."""
  name_not_contains: String

  """All values starting with the given string."""
  name_starts_with: String

  """All values not starting with the given string."""
  name_not_starts_with: String

  """All values ending with the given string."""
  name_ends_with: String

  """All values not ending with the given string."""
  name_not_ends_with: String
  episodes_every: TvEpisodeWhereInput
  episodes_some: TvEpisodeWhereInput
  episodes_none: TvEpisodeWhereInput
}

input TvShowWhereUniqueInput {
  id: ID
}

type WeightHistoryItem implements Node {
  id: ID!
  weight: Float
  date: DateTime!
  human(where: HumanWhereInput): Human!
}

"""A connection to a list of items."""
type WeightHistoryItemConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [WeightHistoryItemEdge]!
  aggregate: AggregateWeightHistoryItem!
}

input WeightHistoryItemCreateInput {
  weight: Float
  date: DateTime!
  human: HumanCreateOneWithoutWeight_historyInput!
}

input WeightHistoryItemCreateManyWithoutHumanInput {
  create: [WeightHistoryItemCreateWithoutHumanInput!]
  connect: [WeightHistoryItemWhereUniqueInput!]
}

input WeightHistoryItemCreateWithoutHumanInput {
  weight: Float
  date: DateTime!
}

"""An edge in a connection."""
type WeightHistoryItemEdge {
  """The item at the end of the edge."""
  node: WeightHistoryItem!

  """A cursor for use in pagination."""
  cursor: String!
}

enum WeightHistoryItemOrderByInput {
  id_ASC
  id_DESC
  weight_ASC
  weight_DESC
  date_ASC
  date_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type WeightHistoryItemPreviousValues {
  id: ID!
  weight: Float
  date: DateTime!
}

type WeightHistoryItemSubscriptionPayload {
  mutation: MutationType!
  node: WeightHistoryItem
  updatedFields: [String!]
  previousValues: WeightHistoryItemPreviousValues
}

input WeightHistoryItemSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [WeightHistoryItemSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [WeightHistoryItemSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [WeightHistoryItemSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: WeightHistoryItemWhereInput
}

input WeightHistoryItemUpdateInput {
  weight: Float
  date: DateTime
  human: HumanUpdateOneWithoutWeight_historyInput
}

input WeightHistoryItemUpdateManyWithoutHumanInput {
  create: [WeightHistoryItemCreateWithoutHumanInput!]
  connect: [WeightHistoryItemWhereUniqueInput!]
  disconnect: [WeightHistoryItemWhereUniqueInput!]
  delete: [WeightHistoryItemWhereUniqueInput!]
  update: [WeightHistoryItemUpdateWithWhereUniqueWithoutHumanInput!]
  upsert: [WeightHistoryItemUpsertWithWhereUniqueWithoutHumanInput!]
}

input WeightHistoryItemUpdateWithoutHumanDataInput {
  weight: Float
  date: DateTime
}

input WeightHistoryItemUpdateWithWhereUniqueWithoutHumanInput {
  where: WeightHistoryItemWhereUniqueInput!
  data: WeightHistoryItemUpdateWithoutHumanDataInput!
}

input WeightHistoryItemUpsertWithWhereUniqueWithoutHumanInput {
  where: WeightHistoryItemWhereUniqueInput!
  update: WeightHistoryItemUpdateWithoutHumanDataInput!
  create: WeightHistoryItemCreateWithoutHumanInput!
}

input WeightHistoryItemWhereInput {
  """Logical AND on all given filters."""
  AND: [WeightHistoryItemWhereInput!]

  """Logical OR on all given filters."""
  OR: [WeightHistoryItemWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [WeightHistoryItemWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  weight: Float

  """All values that are not equal to given value."""
  weight_not: Float

  """All values that are contained in given list."""
  weight_in: [Float!]

  """All values that are not contained in given list."""
  weight_not_in: [Float!]

  """All values less than the given value."""
  weight_lt: Float

  """All values less than or equal the given value."""
  weight_lte: Float

  """All values greater than the given value."""
  weight_gt: Float

  """All values greater than or equal the given value."""
  weight_gte: Float
  date: DateTime

  """All values that are not equal to given value."""
  date_not: DateTime

  """All values that are contained in given list."""
  date_in: [DateTime!]

  """All values that are not contained in given list."""
  date_not_in: [DateTime!]

  """All values less than the given value."""
  date_lt: DateTime

  """All values less than or equal the given value."""
  date_lte: DateTime

  """All values greater than the given value."""
  date_gt: DateTime

  """All values greater than or equal the given value."""
  date_gte: DateTime
  human: HumanWhereInput
}

input WeightHistoryItemWhereUniqueInput {
  id: ID
}

type WishList {
  balance: Float!
  items(where: GoodOrServiceWhereInput, orderBy: GoodOrServiceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [GoodOrService!]
}

"""A connection to a list of items."""
type WishListConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [WishListEdge]!
  aggregate: AggregateWishList!
}

input WishListCreateInput {
  balance: Float
  items: GoodOrServiceCreateManyInput
}

"""An edge in a connection."""
type WishListEdge {
  """The item at the end of the edge."""
  node: WishList!

  """A cursor for use in pagination."""
  cursor: String!
}

enum WishListOrderByInput {
  balance_ASC
  balance_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type WishListPreviousValues {
  balance: Float!
}

type WishListSubscriptionPayload {
  mutation: MutationType!
  node: WishList
  updatedFields: [String!]
  previousValues: WishListPreviousValues
}

input WishListSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [WishListSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [WishListSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [WishListSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: WishListWhereInput
}

input WishListUpdateInput {
  balance: Float
  items: GoodOrServiceUpdateManyInput
}

input WishListWhereInput {
  """Logical AND on all given filters."""
  AND: [WishListWhereInput!]

  """Logical OR on all given filters."""
  OR: [WishListWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [WishListWhereInput!]
  balance: Float

  """All values that are not equal to given value."""
  balance_not: Float

  """All values that are contained in given list."""
  balance_in: [Float!]

  """All values that are not contained in given list."""
  balance_not_in: [Float!]

  """All values less than the given value."""
  balance_lt: Float

  """All values less than or equal the given value."""
  balance_lte: Float

  """All values greater than the given value."""
  balance_gt: Float

  """All values greater than or equal the given value."""
  balance_gte: Float
  items_every: GoodOrServiceWhereInput
  items_some: GoodOrServiceWhereInput
  items_none: GoodOrServiceWhereInput
}
